#pragma once

#include <windows.h>
#include <winternl.h>
#include <iostream>
#include <memory>
#include <map>
#include <tuple>
#include <sstream>
#include <stdexcept>
#include <iomanip> 
#include <algorithm>
#include <type_traits>

#include "payloads.h"

using namespace std;



// ===========================================
// FUNCTION DECLARATIONS
//


const wchar_t* getErrorString(DWORD error);


/**
 * Metaprogrammed way of telling whether a template's type
 * is a subtype of a base template. To be used for instance
 * while telling whether passed template's type is a std::string/
 * std::wstring as it must be subtype of template std::basic_string.
**/
template <template <typename...> class Base, typename...Ts>
std::true_type is_base_of_template_implementation(const Base<Ts...>*);

template <template <typename...> class Base>
std::false_type is_base_of_template_implementation(...);

template <template <typename...> class Base, typename T>
using is_base_of_template = decltype(is_base_of_template_implementation<Base>(std::declval<T*>()));

template<typename T>
inline T trim(const T &s) {
	static_assert(
		is_base_of_template<std::basic_string, T>::value, 
		"T must inherit from std::basic_string"
	);
	
   	auto wsfront = std::find_if_not(s.begin(), s.end(), [](int c){
   		return std::isspace(c);
	});
	
   	auto wsback = std::find_if_not(s.rbegin(), s.rend(), [](int c){
	   	return std::isspace(c);
	}).base();
	
   	return (wsback <= wsfront ? T() : T(wsfront, wsback));
}

