#pragma once

#include <windows.h>
#include <winternl.h>
#include <iostream>
#include <memory>
#include <map>
#include <tuple>
#include <sstream>
#include <stdexcept>
#include <iomanip> 
#include <algorithm>
#include <map>
#include <type_traits>

#include "payloads.h"

using namespace std;


#define random(min, max) (rand() % (int)((max) - (min)) + (min))


// ===========================================
// FUNCTIONS & STRUCTS DECLARATIONS
//

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

/*
typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
*/

enum ReserveObjectType {
	UserApcReserve = 0,
	IoCompletionReserve = 1
};

typedef NTSTATUS (WINAPI *typeNtQueryIntervalProfile)(
	DWORD ProfileSource, 
	PULONG Interval
);

typedef NTSTATUS (WINAPI *typeNtAllocateVirtualMemory)(
    HANDLE ProcessHandle,
    const PVOID *BaseAddress,
    ULONG ZeroBits,
    const PULONG AllocationSize,
    ULONG AllocationType,
    ULONG Protect
);

typedef NTSTATUS (WINAPI *typeNtMapUserPhysicalPages)(
    PVOID BaseAddress,
    ULONG_PTR NumberOfPages,
    PULONG_PTR UserPfnArray		// Page Frame Numbers
);

typedef NTSTATUS (WINAPI *typeNtAllocateReserveObject)(
    PHANDLE hObject,
    PVOID ObjectAttributes,
    ReserveObjectType ObjectType
);


const wchar_t* getErrorString(DWORD error);
shared_ptr<PUCHAR> adjustPayloadEpilogue(UCHAR retNumber, bool addPopEbp = false);
bool leakCurrentProcessObjectsAddresses(std::map<HANDLE, PVOID> &objectsMap);


/**
 * Metaprogrammed way of telling whether a template's type
 * is a subtype of a base template. To be used for instance
 * while telling whether passed template's type is a std::string/
 * std::wstring as it must be subtype of template std::basic_string.
**/
template <template <typename...> class Base, typename...Ts>
std::true_type is_base_of_template_implementation(const Base<Ts...>*);

template <template <typename...> class Base>
std::false_type is_base_of_template_implementation(...);

template <template <typename...> class Base, typename T>
using is_base_of_template = decltype(is_base_of_template_implementation<Base>(std::declval<T*>()));

template<typename T>
inline T trim(const T &s) {
	static_assert(
		is_base_of_template<std::basic_string, T>::value, 
		"T must inherit from std::basic_string"
	);
	
   	auto wsfront = std::find_if_not(s.begin(), s.end(), [](int c){
   		return std::isspace(c);
	});
	
   	auto wsback = std::find_if_not(s.rbegin(), s.rend(), [](int c){
	   	return std::isspace(c);
	}).base();
	
   	return (wsback <= wsfront ? T() : T(wsfront, wsback));
}

